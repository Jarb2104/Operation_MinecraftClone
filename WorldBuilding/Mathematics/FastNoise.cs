// MIT License
//
// Copyright(c) 2020 Jordan Peck (jordan.me2@gmail.com)
// Copyright(c) 2020 Contributors
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files(the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// .'',;:cldxkO00KKXXNNWWWNNXKOkxdollcc::::::;:::ccllloooolllllllllooollc:,'...        ...........',;cldxkO000Okxdlc::;;;,,;;;::cclllllll
// ..',;:ldxO0KXXNNNNNNNNXXK0kxdolcc::::::;;;,,,,,,;;;;;;;;;;:::cclllllc:;'....       ...........',;:ldxO0KXXXK0Okxdolc::;;;;::cllodddddo
// ...',:loxO0KXNNNNNXXKK0Okxdolc::;::::::::;;;,,'''''.....''',;:clllllc:;,'............''''''''',;:loxO0KXNNNNNXK0Okxdollccccllodxxxxxxd
// ....';:ldkO0KXXXKK00Okxdolcc:;;;;;::cclllcc:;;,''..... ....',;clooddolcc:;;;;,,;;;;;::::;;;;;;:cloxk0KXNWWWWWWNXKK0Okxddoooddxxkkkkkxx
// .....';:ldxkOOOOOkxxdolcc:;;;,,,;;:cllooooolcc:;'...      ..,:codxkkkxddooollloooooooollcc:::::clodkO0KXNWWWWWWNNXK00Okxxxxxxxxkkkkxxx
// . ....';:cloddddo___________,,,,;;:clooddddoolc:,...      ..,:ldx__00OOOkkk___kkkkkkxxdollc::::cclodkO0KXXNNNNNNXXK0OOkxxxxxxxxxxxxddd
// .......',;:cccc:|           |,,,;;:cclooddddoll:;'..     ..';cox|  \KKK000|   |KK00OOkxdocc___;::clldxxkO0KKKKK00Okkxdddddddddddddddoo
// .......'',,,,,''|   ________|',,;;::cclloooooolc:;'......___:ldk|   \KK000|   |XKKK0Okxolc|   |;;::cclodxxkkkkxxdoolllcclllooodddooooo
// ''......''''....|   |  ....'',,,,;;;::cclloooollc:;,''.'|   |oxk|    \OOO0|   |KKK00Oxdoll|___|;;;;;::ccllllllcc::;;,,;;;:cclloooooooo
// ;;,''.......... |   |_____',,;;;____:___cllo________.___|   |___|     \xkk|   |KK_______ool___:::;________;;;_______...'',;;:ccclllloo
// c:;,''......... |         |:::/     '   |lo/        |           |      \dx|   |0/       \d|   |cc/        |'/       \......',,;;:ccllo
// ol:;,'..........|    _____|ll/    __    |o/   ______|____    ___|   |   \o|   |/   ___   \|   |o/   ______|/   ___   \ .......'',;:clo
// dlc;,...........|   |::clooo|    /  |   |x\___   \KXKKK0|   |dol|   |\   \|   |   |   |   |   |d\___   \..|   |  /   /       ....',:cl
// xoc;'...  .....'|   |llodddd|    \__|   |_____\   \KKK0O|   |lc:|   |'\       |   |___|   |   |_____\   \.|   |_/___/...      ...',;:c
// dlc;'... ....',;|   |oddddddo\          |          |Okkx|   |::;|   |..\      |\         /|   |          | \         |...    ....',;:c
// ol:,'.......',:c|___|xxxddollc\_____,___|_________/ddoll|___|,,,|___|...\_____|:\ ______/l|___|_________/...\________|'........',;::cc
// c:;'.......';:codxxkkkkxxolc::;::clodxkOO0OOkkxdollc::;;,,''''',,,,''''''''''',,'''''',;:loxkkOOkxol:;,'''',,;:ccllcc:;,'''''',;::ccll
// ;,'.......',:codxkOO0OOkxdlc:;,,;;:cldxxkkxxdolc:;;,,''.....'',;;:::;;,,,'''''........,;cldkO0KK0Okdoc::;;::cloodddoolc:;;;;;::ccllooo
// .........',;:lodxOO0000Okdoc:,,',,;:clloddoolc:;,''.......'',;:clooollc:;;,,''.......',:ldkOKXNNXX0Oxdolllloddxxxxxxdolccccccllooodddd
// .    .....';:cldxkO0000Okxol:;,''',,;::cccc:;,,'.......'',;:cldxxkkxxdolc:;;,'.......';coxOKXNWWWNXKOkxddddxxkkkkkkxdoollllooddxxxxkkk
//       ....',;:codxkO000OOxdoc:;,''',,,;;;;,''.......',,;:clodkO00000Okxolc::;,,''..',;:ldxOKXNWWWNNK0OkkkkkkkkkkkxxddooooodxxkOOOOO000
//       ....',;;clodxkkOOOkkdolc:;,,,,,,,,'..........,;:clodxkO0KKXKK0Okxdolcc::;;,,,;;:codkO0XXNNNNXKK0OOOOOkkkkxxdoollloodxkO0KKKXXXXX
//
// VERSION: 1.0.1
// https://github.com/Auburn/FastNoiseLite

using System.Runtime.CompilerServices;

// Switch between using decimals or doubles for input position
//using FNLdecimal = System.Single;
//using FNLdecimal = System.Double;
using FNLdecimal = System.Decimal;

namespace WorldBuilding.Mathematics
{
    public class FastNoiseLite
    {
        private const short INLINE = 256; // MethodImplOptions.AggressiveInlining;
        private const short OPTIMISE = 512; // MethodImplOptions.AggressiveOptimization;

        public enum NoiseType
        {
            OpenSimplex2,
            OpenSimplex2S,
            Cellular,
            Perlin,
            ValueCubic,
            Value
        };

        public enum RotationType3D
        {
            None,
            ImproveXYPlanes,
            ImproveXZPlanes
        };

        public enum FractalType
        {
            None,
            FBm,
            Ridged,
            PingPong,
            DomainWarpProgressive,
            DomainWarpIndependent
        };

        public enum CellularDistanceFunction
        {
            Euclidean,
            EuclideanSq,
            Manhattan,
            Hybrid
        };

        public enum CellularReturnType
        {
            CellValue,
            Distance,
            Distance2,
            Distance2Add,
            Distance2Sub,
            Distance2Mul,
            Distance2Div
        };

        public enum DomainWarpType
        {
            OpenSimplex2,
            OpenSimplex2Reduced,
            BasicGrid
        };

        private enum TransformType3D
        {
            None,
            ImproveXYPlanes,
            ImproveXZPlanes,
            DefaultOpenSimplex2
        };

        private int mSeed = 1337;
        private decimal mFrequency = 0.01m;
        private NoiseType mNoiseType = NoiseType.OpenSimplex2;
        private RotationType3D mRotationType3D = RotationType3D.None;
        private TransformType3D mTransformType3D = TransformType3D.DefaultOpenSimplex2;

        private FractalType mFractalType = FractalType.None;
        private int mOctaves = 3;
        private decimal mLacunarity = 2.0m;
        private decimal mGain = 0.5m;
        private decimal mWeightedStrength = 0.0m;
        private decimal mPingPongStrength = 2.0m;

        private decimal mFractalBounding = 1 / 1.75m;

        private CellularDistanceFunction mCellularDistanceFunction = CellularDistanceFunction.EuclideanSq;
        private CellularReturnType mCellularReturnType = CellularReturnType.Distance;
        private decimal mCellularJitterModifier = 1.0m;

        private DomainWarpType mDomainWarpType = DomainWarpType.OpenSimplex2;
        private TransformType3D mWarpTransformType3D = TransformType3D.DefaultOpenSimplex2;
        private decimal mDomainWarpAmp = 1.0m;

        /// <summary>
        /// Create new FastNoise object with optional seed
        /// </summary>
        public FastNoiseLite(int seed = 1337)
        {
            SetSeed(seed);
        }

        /// <summary>
        /// Sets seed used for all noise types
        /// </summary>
        /// <remarks>
        /// Default: 1337
        /// </remarks>
        public void SetSeed(int seed) { mSeed = seed; }

        /// <summary>
        /// Sets frequency for all noise types
        /// </summary>
        /// <remarks>
        /// Default: 0.01
        /// </remarks>
        public void SetFrequency(decimal frequency) { mFrequency = frequency; }

        /// <summary>
        /// Sets noise algorithm used for GetNoise(...)
        /// </summary>
        /// <remarks>
        /// Default: OpenSimplex2
        /// </remarks>
        public void SetNoiseType(NoiseType noiseType)
        {
            mNoiseType = noiseType;
            UpdateTransformType3D();
        }

        /// <summary>
        /// Sets domain rotation type for 3D Noise and 3D DomainWarp.
        /// Can aid in reducing directional artifacts when sampling a 2D plane in 3D
        /// </summary>
        /// <remarks>
        /// Default: None
        /// </remarks>
        public void SetRotationType3D(RotationType3D rotationType3D)
        {
            mRotationType3D = rotationType3D;
            UpdateTransformType3D();
            UpdateWarpTransformType3D();
        }

        /// <summary>
        /// Sets method for combining octaves in all fractal noise types
        /// </summary>
        /// <remarks>
        /// Default: None
        /// Note: FractalType.DomainWarp... only affects DomainWarp(...)
        /// </remarks>
        public void SetFractalType(FractalType fractalType) { mFractalType = fractalType; }

        /// <summary>
        /// Sets octave count for all fractal noise types 
        /// </summary>
        /// <remarks>
        /// Default: 3
        /// </remarks>
        public void SetFractalOctaves(int octaves)
        {
            mOctaves = octaves;
            CalculateFractalBounding();
        }

        /// <summary>
        /// Sets octave lacunarity for all fractal noise types
        /// </summary>
        /// <remarks>
        /// Default: 2.0
        /// </remarks>
        public void SetFractalLacunarity(decimal lacunarity) { mLacunarity = lacunarity; }

        /// <summary>
        /// Sets octave gain for all fractal noise types
        /// </summary>
        /// <remarks>
        /// Default: 0.5
        /// </remarks>
        public void SetFractalGain(decimal gain)
        {
            mGain = gain;
            CalculateFractalBounding();
        }

        /// <summary>
        /// Sets octave weighting for all none DomainWarp fratal types
        /// </summary>
        /// <remarks>
        /// Default: 0.0
        /// Note: Keep between 0...1 to maintain -1...1 output bounding
        /// </remarks>
        public void SetFractalWeightedStrength(decimal weightedStrength) { mWeightedStrength = weightedStrength; }

        /// <summary>
        /// Sets strength of the fractal ping pong effect
        /// </summary>
        /// <remarks>
        /// Default: 2.0
        /// </remarks>
        public void SetFractalPingPongStrength(decimal pingPongStrength) { mPingPongStrength = pingPongStrength; }


        /// <summary>
        /// Sets distance function used in cellular noise calculations
        /// </summary>
        /// <remarks>
        /// Default: Distance
        /// </remarks>
        public void SetCellularDistanceFunction(CellularDistanceFunction cellularDistanceFunction) { mCellularDistanceFunction = cellularDistanceFunction; }

        /// <summary>
        /// Sets return type from cellular noise calculations
        /// </summary>
        /// <remarks>
        /// Default: EuclideanSq
        /// </remarks>
        public void SetCellularReturnType(CellularReturnType cellularReturnType) { mCellularReturnType = cellularReturnType; }

        /// <summary>
        /// Sets the maximum distance a cellular point can move from it's grid position
        /// </summary>
        /// <remarks>
        /// Default: 1.0
        /// Note: Setting this higher than 1 will cause artifacts
        /// </remarks> 
        public void SetCellularJitter(decimal cellularJitter) { mCellularJitterModifier = cellularJitter; }


        /// <summary>
        /// Sets the warp algorithm when using DomainWarp(...)
        /// </summary>
        /// <remarks>
        /// Default: OpenSimplex2
        /// </remarks>
        public void SetDomainWarpType(DomainWarpType domainWarpType)
        {
            mDomainWarpType = domainWarpType;
            UpdateWarpTransformType3D();
        }


        /// <summary>
        /// Sets the maximum warp distance from original position when using DomainWarp(...)
        /// </summary>
        /// <remarks>
        /// Default: 1.0
        /// </remarks>
        public void SetDomainWarpAmp(decimal domainWarpAmp) { mDomainWarpAmp = domainWarpAmp; }


        /// <summary>
        /// 2D noise at given position using current settings
        /// </summary>
        /// <returns>
        /// Noise output bounded between -1...1
        /// </returns>
        [MethodImpl(OPTIMISE)]
        public decimal GetNoise(FNLdecimal x, FNLdecimal y)
        {
            TransformNoiseCoordinate(ref x, ref y);

            return mFractalType switch
            {
                FractalType.FBm => GenFractalFBm(x, y),
                FractalType.Ridged => GenFractalRidged(x, y),
                FractalType.PingPong => GenFractalPingPong(x, y),
                _ => GenNoiseSingle(mSeed, x, y),
            };
        }

        /// <summary>
        /// 3D noise at given position using current settings
        /// </summary>
        /// <returns>
        /// Noise output bounded between -1...1
        /// </returns>
        [MethodImpl(OPTIMISE)]
        public decimal GetNoise(FNLdecimal x, FNLdecimal y, FNLdecimal z)
        {
            TransformNoiseCoordinate(ref x, ref y, ref z);

            return mFractalType switch
            {
                FractalType.FBm => GenFractalFBm(x, y, z),
                FractalType.Ridged => GenFractalRidged(x, y, z),
                FractalType.PingPong => GenFractalPingPong(x, y, z),
                _ => GenNoiseSingle(mSeed, x, y, z),
            };
        }


        /// <summary>
        /// 2D warps the input position using current domain warp settings
        /// </summary>
        /// <example>
        /// Example usage with GetNoise
        /// <code>DomainWarp(ref x, ref y)
        /// noise = GetNoise(x, y)</code>
        /// </example>
        [MethodImpl(OPTIMISE)]
        public void DomainWarp(ref FNLdecimal x, ref FNLdecimal y)
        {
            switch (mFractalType)
            {
                default:
                    DomainWarpSingle(ref x, ref y);
                    break;
                case FractalType.DomainWarpProgressive:
                    DomainWarpFractalProgressive(ref x, ref y);
                    break;
                case FractalType.DomainWarpIndependent:
                    DomainWarpFractalIndependent(ref x, ref y);
                    break;
            }
        }

        /// <summary>
        /// 3D warps the input position using current domain warp settings
        /// </summary>
        /// <example>
        /// Example usage with GetNoise
        /// <code>DomainWarp(ref x, ref y, ref z)
        /// noise = GetNoise(x, y, z)</code>
        /// </example>
        [MethodImpl(OPTIMISE)]
        public void DomainWarp(ref FNLdecimal x, ref FNLdecimal y, ref FNLdecimal z)
        {
            switch (mFractalType)
            {
                default:
                    DomainWarpSingle(ref x, ref y, ref z);
                    break;
                case FractalType.DomainWarpProgressive:
                    DomainWarpFractalProgressive(ref x, ref y, ref z);
                    break;
                case FractalType.DomainWarpIndependent:
                    DomainWarpFractalIndependent(ref x, ref y, ref z);
                    break;
            }
        }


        private static readonly decimal[] Gradients2D =
        {
         0.130526192220052m,  0.99144486137381m,   0.38268343236509m,   0.923879532511287m,  0.608761429008721m,  0.793353340291235m,  0.793353340291235m,  0.608761429008721m,
         0.923879532511287m,  0.38268343236509m,   0.99144486137381m,   0.130526192220051m,  0.99144486137381m,  -0.130526192220051m,  0.923879532511287m, -0.38268343236509m,
         0.793353340291235m, -0.60876142900872m,   0.608761429008721m, -0.793353340291235m,  0.38268343236509m,  -0.923879532511287m,  0.130526192220052m, -0.99144486137381m,
        -0.130526192220052m, -0.99144486137381m,  -0.38268343236509m,  -0.923879532511287m, -0.608761429008721m, -0.793353340291235m, -0.793353340291235m, -0.608761429008721m,
        -0.923879532511287m, -0.38268343236509m,  -0.99144486137381m,  -0.130526192220052m, -0.99144486137381m,   0.130526192220051m, -0.923879532511287m,  0.38268343236509m,
        -0.793353340291235m,  0.608761429008721m, -0.608761429008721m,  0.793353340291235m, -0.38268343236509m,   0.923879532511287m, -0.130526192220052m,  0.99144486137381m,
         0.130526192220052m,  0.99144486137381m,   0.38268343236509m,   0.923879532511287m,  0.608761429008721m,  0.793353340291235m,  0.793353340291235m,  0.608761429008721m,
         0.923879532511287m,  0.38268343236509m,   0.99144486137381m,   0.130526192220051m,  0.99144486137381m,  -0.130526192220051m,  0.923879532511287m, -0.38268343236509m,
         0.793353340291235m, -0.60876142900872m,   0.608761429008721m, -0.793353340291235m,  0.38268343236509m,  -0.923879532511287m,  0.130526192220052m, -0.99144486137381m,
        -0.130526192220052m, -0.99144486137381m,  -0.38268343236509m,  -0.923879532511287m, -0.608761429008721m, -0.793353340291235m, -0.793353340291235m, -0.608761429008721m,
        -0.923879532511287m, -0.38268343236509m,  -0.99144486137381m,  -0.130526192220052m, -0.99144486137381m,   0.130526192220051m, -0.923879532511287m,  0.38268343236509m,
        -0.793353340291235m,  0.608761429008721m, -0.608761429008721m,  0.793353340291235m, -0.38268343236509m,   0.923879532511287m, -0.130526192220052m,  0.99144486137381m,
         0.130526192220052m,  0.99144486137381m,   0.38268343236509m,   0.923879532511287m,  0.608761429008721m,  0.793353340291235m,  0.793353340291235m,  0.608761429008721m,
         0.923879532511287m,  0.38268343236509m,   0.99144486137381m,   0.130526192220051m,  0.99144486137381m,  -0.130526192220051m,  0.923879532511287m, -0.38268343236509m,
         0.793353340291235m, -0.60876142900872m,   0.608761429008721m, -0.793353340291235m,  0.38268343236509m,  -0.923879532511287m,  0.130526192220052m, -0.99144486137381m,
        -0.130526192220052m, -0.99144486137381m,  -0.38268343236509m,  -0.923879532511287m, -0.608761429008721m, -0.793353340291235m, -0.793353340291235m, -0.608761429008721m,
        -0.923879532511287m, -0.38268343236509m,  -0.99144486137381m,  -0.130526192220052m, -0.99144486137381m,   0.130526192220051m, -0.923879532511287m,  0.38268343236509m,
        -0.793353340291235m,  0.608761429008721m, -0.608761429008721m,  0.793353340291235m, -0.38268343236509m,   0.923879532511287m, -0.130526192220052m,  0.99144486137381m,
         0.130526192220052m,  0.99144486137381m,   0.38268343236509m,   0.923879532511287m,  0.608761429008721m,  0.793353340291235m,  0.793353340291235m,  0.608761429008721m,
         0.923879532511287m,  0.38268343236509m,   0.99144486137381m,   0.130526192220051m,  0.99144486137381m,  -0.130526192220051m,  0.923879532511287m, -0.38268343236509m,
         0.793353340291235m, -0.60876142900872m,   0.608761429008721m, -0.793353340291235m,  0.38268343236509m,  -0.923879532511287m,  0.130526192220052m, -0.99144486137381m,
        -0.130526192220052m, -0.99144486137381m,  -0.38268343236509m,  -0.923879532511287m, -0.608761429008721m, -0.793353340291235m, -0.793353340291235m, -0.608761429008721m,
        -0.923879532511287m, -0.38268343236509m,  -0.99144486137381m,  -0.130526192220052m, -0.99144486137381m,   0.130526192220051m, -0.923879532511287m,  0.38268343236509m,
        -0.793353340291235m,  0.608761429008721m, -0.608761429008721m,  0.793353340291235m, -0.38268343236509m,   0.923879532511287m, -0.130526192220052m,  0.99144486137381m,
         0.130526192220052m,  0.99144486137381m,   0.38268343236509m,   0.923879532511287m,  0.608761429008721m,  0.793353340291235m,  0.793353340291235m,  0.608761429008721m,
         0.923879532511287m,  0.38268343236509m,   0.99144486137381m,   0.130526192220051m,  0.99144486137381m,  -0.130526192220051m,  0.923879532511287m, -0.38268343236509m,
         0.793353340291235m, -0.60876142900872m,   0.608761429008721m, -0.793353340291235m,  0.38268343236509m,  -0.923879532511287m,  0.130526192220052m, -0.99144486137381m,
        -0.130526192220052m, -0.99144486137381m,  -0.38268343236509m,  -0.923879532511287m, -0.608761429008721m, -0.793353340291235m, -0.793353340291235m, -0.608761429008721m,
        -0.923879532511287m, -0.38268343236509m,  -0.99144486137381m,  -0.130526192220052m, -0.99144486137381m,   0.130526192220051m, -0.923879532511287m,  0.38268343236509m,
        -0.793353340291235m,  0.608761429008721m, -0.608761429008721m,  0.793353340291235m, -0.38268343236509m,   0.923879532511287m, -0.130526192220052m,  0.99144486137381m,
         0.38268343236509m,   0.923879532511287m,  0.923879532511287m,  0.38268343236509m,   0.923879532511287m, -0.38268343236509m,   0.38268343236509m,  -0.923879532511287m,
        -0.38268343236509m,  -0.923879532511287m, -0.923879532511287m, -0.38268343236509m,  -0.923879532511287m,  0.38268343236509m,  -0.38268343236509m,   0.923879532511287m,
    };

        private static readonly decimal[] RandVecs2D =
        {
        -0.2700222198m, -0.9628540911m, 0.3863092627m, -0.9223693152m, 0.04444859006m, -0.999011673m, -0.5992523158m, -0.8005602176m, -0.7819280288m, 0.6233687174m, 0.9464672271m, 0.3227999196m, -0.6514146797m, -0.7587218957m, 0.9378472289m, 0.347048376m,
        -0.8497875957m, -0.5271252623m, -0.879042592m, 0.4767432447m, -0.892300288m, -0.4514423508m, -0.379844434m, -0.9250503802m, -0.9951650832m, 0.0982163789m, 0.7724397808m, -0.6350880136m, 0.7573283322m, -0.6530343002m, -0.9928004525m, -0.119780055m,
        -0.0532665713m, 0.9985803285m, 0.9754253726m, -0.2203300762m, -0.7665018163m, 0.6422421394m, 0.991636706m, 0.1290606184m, -0.994696838m, 0.1028503788m, -0.5379205513m, -0.84299554m, 0.5022815471m, -0.8647041387m, 0.4559821461m, -0.8899889226m,
        -0.8659131224m, -0.5001944266m, 0.0879458407m, -0.9961252577m, -0.5051684983m, 0.8630207346m, 0.7753185226m, -0.6315704146m, -0.6921944612m, 0.7217110418m, -0.5191659449m, -0.8546734591m, 0.8978622882m, -0.4402764035m, -0.1706774107m, 0.9853269617m,
        -0.9353430106m, -0.3537420705m, -0.9992404798m, 0.03896746794m, -0.2882064021m, -0.9575683108m, -0.9663811329m, 0.2571137995m, -0.8759714238m, -0.4823630009m, -0.8303123018m, -0.5572983775m, 0.05110133755m, -0.9986934731m, -0.8558373281m, -0.5172450752m,
        0.09887025282m, 0.9951003332m, 0.9189016087m, 0.3944867976m, -0.2439375892m, -0.9697909324m, -0.8121409387m, -0.5834613061m, -0.9910431363m, 0.1335421355m, 0.8492423985m, -0.5280031709m, -0.9717838994m, -0.2358729591m, 0.9949457207m, 0.1004142068m,
        0.6241065508m, -0.7813392434m, 0.662910307m, 0.7486988212m, -0.7197418176m, 0.6942418282m, -0.8143370775m, -0.5803922158m, 0.104521054m, -0.9945226741m, -0.1065926113m, -0.9943027784m, 0.445799684m, -0.8951327509m, 0.105547406m, 0.9944142724m,
        -0.992790267m, 0.1198644477m, -0.8334366408m, 0.552615025m, 0.9115561563m, -0.4111755999m, 0.8285544909m, -0.5599084351m, 0.7217097654m, -0.6921957921m, 0.4940492677m, -0.8694339084m, -0.3652321272m, -0.9309164803m, -0.9696606758m, 0.2444548501m,
        0.08925509731m, -0.996008799m, 0.5354071276m, -0.8445941083m, -0.1053576186m, 0.9944343981m, -0.9890284586m, 0.1477251101m, 0.004856104961m, 0.9999882091m, 0.9885598478m, 0.1508291331m, 0.9286129562m, -0.3710498316m, -0.5832393863m, -0.8123003252m,
        0.3015207509m, 0.9534596146m, -0.9575110528m, 0.2883965738m, 0.9715802154m, -0.2367105511m, 0.229981792m, 0.9731949318m, 0.955763816m, -0.2941352207m, 0.740956116m, 0.6715534485m, -0.9971513787m, -0.07542630764m, 0.6905710663m, -0.7232645452m,
        -0.290713703m, -0.9568100872m, 0.5912777791m, -0.8064679708m, -0.9454592212m, -0.325740481m, 0.6664455681m, 0.74555369m, 0.6236134912m, 0.7817328275m, 0.9126993851m, -0.4086316587m, -0.8191762011m, 0.5735419353m, -0.8812745759m, -0.4726046147m,
        0.9953313627m, 0.09651672651m, 0.9855650846m, -0.1692969699m, -0.8495980887m, 0.5274306472m, 0.6174853946m, -0.7865823463m, 0.8508156371m, 0.52546432m, 0.9985032451m, -0.05469249926m, 0.1971371563m, -0.9803759185m, 0.6607855748m, -0.7505747292m,
        -0.03097494063m, 0.9995201614m, -0.6731660801m, 0.739491331m, -0.7195018362m, -0.6944905383m, 0.9727511689m, 0.2318515979m, 0.9997059088m, -0.0242506907m, 0.4421787429m, -0.8969269532m, 0.9981350961m, -0.061043673m, -0.9173660799m, -0.3980445648m,
        -0.8150056635m, -0.5794529907m, -0.8789331304m, 0.4769450202m, 0.0158605829m, 0.999874213m, -0.8095464474m, 0.5870558317m, -0.9165898907m, -0.3998286786m, -0.8023542565m, 0.5968480938m, -0.5176737917m, 0.8555780767m, -0.8154407307m, -0.5788405779m,
        0.4022010347m, -0.9155513791m, -0.9052556868m, -0.4248672045m, 0.7317445619m, 0.6815789728m, -0.5647632201m, -0.8252529947m, -0.8403276335m, -0.5420788397m, -0.9314281527m, 0.363925262m, 0.5238198472m, 0.8518290719m, 0.7432803869m, -0.6689800195m,
        -0.985371561m, -0.1704197369m, 0.4601468731m, 0.88784281m, 0.825855404m, 0.5638819483m, 0.6182366099m, 0.7859920446m, 0.8331502863m, -0.553046653m, 0.1500307506m, 0.9886813308m, -0.662330369m, -0.7492119075m, -0.668598664m, 0.743623444m,
        0.7025606278m, 0.7116238924m, -0.5419389763m, -0.8404178401m, -0.3388616456m, 0.9408362159m, 0.8331530315m, 0.5530425174m, -0.2989720662m, -0.9542618632m, 0.2638522993m, 0.9645630949m, 0.124108739m, -0.9922686234m, -0.7282649308m, -0.6852956957m,
        0.6962500149m, 0.7177993569m, -0.9183535368m, 0.3957610156m, -0.6326102274m, -0.7744703352m, -0.9331891859m, -0.359385508m, -0.1153779357m, -0.9933216659m, 0.9514974788m, -0.3076565421m, -0.08987977445m, -0.9959526224m, 0.6678496916m, 0.7442961705m,
        0.7952400393m, -0.6062947138m, -0.6462007402m, -0.7631674805m, -0.2733598753m, 0.9619118351m, 0.9669590226m, -0.254931851m, -0.9792894595m, 0.2024651934m, -0.5369502995m, -0.8436138784m, -0.270036471m, -0.9628500944m, -0.6400277131m, 0.7683518247m,
        -0.7854537493m, -0.6189203566m, 0.06005905383m, -0.9981948257m, -0.02455770378m, 0.9996984141m, -0.65983623m, 0.751409442m, -0.6253894466m, -0.7803127835m, -0.6210408851m, -0.7837781695m, 0.8348888491m, 0.5504185768m, -0.1592275245m, 0.9872419133m,
        0.8367622488m, 0.5475663786m, -0.8675753916m, -0.4973056806m, -0.2022662628m, -0.9793305667m, 0.9399189937m, 0.3413975472m, 0.9877404807m, -0.1561049093m, -0.9034455656m, 0.4287028224m, 0.1269804218m, -0.9919052235m, -0.3819600854m, 0.924178821m,
        0.9754625894m, 0.2201652486m, -0.3204015856m, -0.9472818081m, -0.9874760884m, 0.1577687387m, 0.02535348474m, -0.9996785487m, 0.4835130794m, -0.8753371362m, -0.2850799925m, -0.9585037287m, -0.06805516006m, -0.99768156m, -0.7885244045m, -0.6150034663m,
        0.3185392127m, -0.9479096845m, 0.8880043089m, 0.4598351306m, 0.6476921488m, -0.7619021462m, 0.9820241299m, 0.1887554194m, 0.9357275128m, -0.3527237187m, -0.8894895414m, 0.4569555293m, 0.7922791302m, 0.6101588153m, 0.7483818261m, 0.6632681526m,
        -0.7288929755m, -0.6846276581m, 0.8729032783m, -0.4878932944m, 0.8288345784m, 0.5594937369m, 0.08074567077m, 0.9967347374m, 0.9799148216m, -0.1994165048m, -0.580730673m, -0.8140957471m, -0.4700049791m, -0.8826637636m, 0.2409492979m, 0.9705377045m,
        0.9437816757m, -0.3305694308m, -0.8927998638m, -0.4504535528m, -0.8069622304m, 0.5906030467m, 0.06258973166m, 0.9980393407m, -0.9312597469m, 0.3643559849m, 0.5777449785m, 0.8162173362m, -0.3360095855m, -0.941858566m, 0.697932075m, -0.7161639607m,
        -0.002008157227m, -0.9999979837m, -0.1827294312m, -0.9831632392m, -0.6523911722m, 0.7578824173m, -0.4302626911m, -0.9027037258m, -0.9985126289m, -0.05452091251m, -0.01028102172m, -0.9999471489m, -0.4946071129m, 0.8691166802m, -0.2999350194m, 0.9539596344m,
        0.8165471961m, 0.5772786819m, 0.2697460475m, 0.962931498m, -0.7306287391m, -0.6827749597m, -0.7590952064m, -0.6509796216m, -0.907053853m, 0.4210146171m, -0.5104861064m, -0.8598860013m, 0.8613350597m, 0.5080373165m, 0.5007881595m, -0.8655698812m,
        -0.654158152m, 0.7563577938m, -0.8382755311m, -0.545246856m, 0.6940070834m, 0.7199681717m, 0.06950936031m, 0.9975812994m, 0.1702942185m, -0.9853932612m, 0.2695973274m, 0.9629731466m, 0.5519612192m, -0.8338697815m, 0.225657487m, -0.9742067022m,
        0.4215262855m, -0.9068161835m, 0.4881873305m, -0.8727388672m, -0.3683854996m, -0.9296731273m, -0.9825390578m, 0.1860564427m, 0.81256471m, 0.5828709909m, 0.3196460933m, -0.9475370046m, 0.9570913859m, 0.2897862643m, -0.6876655497m, -0.7260276109m,
        -0.9988770922m, -0.047376731m, -0.1250179027m, 0.992154486m, -0.8280133617m, 0.560708367m, 0.9324863769m, -0.3612051451m, 0.6394653183m, 0.7688199442m, -0.01623847064m, -0.9998681473m, -0.9955014666m, -0.09474613458m, -0.81453315m, 0.580117012m,
        0.4037327978m, -0.9148769469m, 0.9944263371m, 0.1054336766m, -0.1624711654m, 0.9867132919m, -0.9949487814m, -0.100383875m, -0.6995302564m, 0.7146029809m, 0.5263414922m, -0.85027327m, -0.5395221479m, 0.841971408m, 0.6579370318m, 0.7530729462m,
        0.01426758847m, -0.9998982128m, -0.6734383991m, 0.7392433447m, 0.639412098m, -0.7688642071m, 0.9211571421m, 0.3891908523m, -0.146637214m, -0.9891903394m, -0.782318098m, 0.6228791163m, -0.5039610839m, -0.8637263605m, -0.7743120191m, -0.6328039957m,
    };

        private static readonly decimal[] Gradients3D =
        {
        0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
        1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
        1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
        0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
        1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
        1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
        0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
        1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
        1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
        0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
        1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
        1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
        0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
        1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
        1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
        1, 1, 0, 0,  0,-1, 1, 0, -1, 1, 0, 0,  0,-1,-1, 0
    };

        private static readonly decimal[] RandVecs3D =
        {
        -0.7292736885m, -0.6618439697m, 0.1735581948m, 0, 0.790292081m, -0.5480887466m, -0.2739291014m, 0, 0.7217578935m, 0.6226212466m, -0.3023380997m, 0, 0.565683137m, -0.8208298145m, -0.0790000257m, 0, 0.760049034m, -0.5555979497m, -0.3370999617m, 0, 0.3713945616m, 0.5011264475m, 0.7816254623m, 0, -0.1277062463m, -0.4254438999m, -0.8959289049m, 0, -0.2881560924m, -0.5815838982m, 0.7607405838m, 0,
        0.5849561111m, -0.662820239m, -0.4674352136m, 0, 0.3307171178m, 0.0391653737m, 0.94291689m, 0, 0.8712121778m, -0.4113374369m, -0.2679381538m, 0, 0.580981015m, 0.7021915846m, 0.4115677815m, 0, 0.503756873m, 0.6330056931m, -0.5878203852m, 0, 0.4493712205m, 0.601390195m, 0.6606022552m, 0, -0.6878403724m, 0.09018890807m, -0.7202371714m, 0, -0.5958956522m, -0.6469350577m, 0.475797649m, 0,
        -0.5127052122m, 0.1946921978m, -0.8361987284m, 0, -0.9911507142m, -0.05410276466m, -0.1212153153m, 0, -0.2149721042m, 0.9720882117m, -0.09397607749m, 0, -0.7518650936m, -0.5428057603m, 0.3742469607m, 0, 0.5237068895m, 0.8516377189m, -0.02107817834m, 0, 0.6333504779m, 0.1926167129m, -0.7495104896m, 0, -0.06788241606m, 0.3998305789m, 0.9140719259m, 0, -0.5538628599m, -0.4729896695m, -0.6852128902m, 0,
        -0.7261455366m, -0.5911990757m, 0.3509933228m, 0, -0.9229274737m, -0.1782808786m, 0.3412049336m, 0, -0.6968815002m, 0.6511274338m, 0.3006480328m, 0, 0.9608044783m, -0.2098363234m, -0.1811724921m, 0, 0.06817146062m, -0.9743405129m, 0.2145069156m, 0, -0.3577285196m, -0.6697087264m, -0.6507845481m, 0, -0.1868621131m, 0.7648617052m, -0.6164974636m, 0, -0.6541697588m, 0.3967914832m, 0.6439087246m, 0,
        0.6993340405m, -0.6164538506m, 0.3618239211m, 0, -0.1546665739m, 0.6291283928m, 0.7617583057m, 0, -0.6841612949m, -0.2580482182m, -0.6821542638m, 0, 0.5383980957m, 0.4258654885m, 0.7271630328m, 0, -0.5026987823m, -0.7939832935m, -0.3418836993m, 0, 0.3202971715m, 0.2834415347m, 0.9039195862m, 0, 0.8683227101m, -0.0003762656404m, -0.4959995258m, 0, 0.791120031m, -0.08511045745m, 0.6057105799m, 0,
        -0.04011016052m, -0.4397248749m, 0.8972364289m, 0, 0.9145119872m, 0.3579346169m, -0.1885487608m, 0, -0.9612039066m, -0.2756484276m, 0.01024666929m, 0, 0.6510361721m, -0.2877799159m, -0.7023778346m, 0, -0.2041786351m, 0.7365237271m, 0.644859585m, 0, -0.7718263711m, 0.3790626912m, 0.5104855816m, 0, -0.3060082741m, -0.7692987727m, 0.5608371729m, 0, 0.454007341m, -0.5024843065m, 0.7357899537m, 0,
        0.4816795475m, 0.6021208291m, -0.6367380315m, 0, 0.6961980369m, -0.3222197429m, 0.641469197m, 0, -0.6532160499m, -0.6781148932m, 0.3368515753m, 0, 0.5089301236m, -0.6154662304m, -0.6018234363m, 0, -0.1635919754m, -0.9133604627m, -0.372840892m, 0, 0.52408019m, -0.8437664109m, 0.1157505864m, 0, 0.5902587356m, 0.4983817807m, -0.6349883666m, 0, 0.5863227872m, 0.494764745m, 0.6414307729m, 0,
        0.6779335087m, 0.2341345225m, 0.6968408593m, 0, 0.7177054546m, -0.6858979348m, 0.120178631m, 0, -0.5328819713m, -0.5205125012m, 0.6671608058m, 0, -0.8654874251m, -0.0700727088m, -0.4960053754m, 0, -0.2861810166m, 0.7952089234m, 0.5345495242m, 0, -0.04849529634m, 0.9810836427m, -0.1874115585m, 0, -0.6358521667m, 0.6058348682m, 0.4781800233m, 0, 0.6254794696m, -0.2861619734m, 0.7258696564m, 0,
        -0.2585259868m, 0.5061949264m, -0.8227581726m, 0, 0.02136306781m, 0.5064016808m, -0.8620330371m, 0, 0.200111773m, 0.8599263484m, 0.4695550591m, 0, 0.4743561372m, 0.6014985084m, -0.6427953014m, 0, 0.6622993731m, -0.5202474575m, -0.5391679918m, 0, 0.08084972818m, -0.6532720452m, 0.7527940996m, 0, -0.6893687501m, 0.0592860349m, 0.7219805347m, 0, -0.1121887082m, -0.9673185067m, 0.2273952515m, 0,
        0.7344116094m, 0.5979668656m, -0.3210532909m, 0, 0.5789393465m, -0.2488849713m, 0.7764570201m, 0, 0.6988182827m, 0.3557169806m, -0.6205791146m, 0, -0.8636845529m, -0.2748771249m, -0.4224826141m, 0, -0.4247027957m, -0.4640880967m, 0.777335046m, 0, 0.5257722489m, -0.8427017621m, 0.1158329937m, 0, 0.9343830603m, 0.316302472m, -0.1639543925m, 0, -0.1016836419m, -0.8057303073m, -0.5834887393m, 0,
        -0.6529238969m, 0.50602126m, -0.5635892736m, 0, -0.2465286165m, -0.9668205684m, -0.06694497494m, 0, -0.9776897119m, -0.2099250524m, -0.007368825344m, 0, 0.7736893337m, 0.5734244712m, 0.2694238123m, 0, -0.6095087895m, 0.4995678998m, 0.6155736747m, 0, 0.5794535482m, 0.7434546771m, 0.3339292269m, 0, -0.8226211154m, 0.08142581855m, 0.5627293636m, 0, -0.510385483m, 0.4703667658m, 0.7199039967m, 0,
        -0.5764971849m, -0.07231656274m, -0.8138926898m, 0, 0.7250628871m, 0.3949971505m, -0.5641463116m, 0, -0.1525424005m, 0.4860840828m, -0.8604958341m, 0, -0.5550976208m, -0.4957820792m, 0.667882296m, 0, -0.1883614327m, 0.9145869398m, 0.357841725m, 0, 0.7625556724m, -0.5414408243m, -0.3540489801m, 0, -0.5870231946m, -0.3226498013m, -0.7424963803m, 0, 0.3051124198m, 0.2262544068m, -0.9250488391m, 0,
        0.6379576059m, 0.577242424m, -0.5097070502m, 0, -0.5966775796m, 0.1454852398m, -0.7891830656m, 0, -0.658330573m, 0.6555487542m, -0.3699414651m, 0, 0.7434892426m, 0.2351084581m, 0.6260573129m, 0, 0.5562114096m, 0.8264360377m, -0.0873632843m, 0, -0.3028940016m, -0.8251527185m, 0.4768419182m, 0, 0.1129343818m, -0.985888439m, -0.1235710781m, 0, 0.5937652891m, -0.5896813806m, 0.5474656618m, 0,
        0.6757964092m, -0.5835758614m, -0.4502648413m, 0, 0.7242302609m, -0.1152719764m, 0.6798550586m, 0, -0.9511914166m, 0.0753623979m, -0.2992580792m, 0, 0.2539470961m, -0.1886339355m, 0.9486454084m, 0, 0.571433621m, -0.1679450851m, -0.8032795685m, 0, -0.06778234979m, 0.3978269256m, 0.9149531629m, 0, 0.6074972649m, 0.733060024m, -0.3058922593m, 0, -0.5435478392m, 0.1675822484m, 0.8224791405m, 0,
        -0.5876678086m, -0.3380045064m, -0.7351186982m, 0, -0.7967562402m, 0.04097822706m, -0.6029098428m, 0, -0.1996350917m, 0.8706294745m, 0.4496111079m, 0, -0.02787660336m, -0.9106232682m, -0.4122962022m, 0, -0.7797625996m, -0.6257634692m, 0.01975775581m, 0, -0.5211232846m, 0.7401644346m, -0.4249554471m, 0, 0.8575424857m, 0.4053272873m, -0.3167501783m, 0, 0.1045223322m, 0.8390195772m, -0.5339674439m, 0,
        0.3501822831m, 0.9242524096m, -0.1520850155m, 0, 0.1987849858m, 0.07647613266m, 0.9770547224m, 0, 0.7845996363m, 0.6066256811m, -0.1280964233m, 0, 0.09006737436m, -0.9750989929m, -0.2026569073m, 0, -0.8274343547m, -0.542299559m, 0.1458203587m, 0, -0.3485797732m, -0.415802277m, 0.840000362m, 0, -0.2471778936m, -0.7304819962m, -0.6366310879m, 0, -0.3700154943m, 0.8577948156m, 0.3567584454m, 0,
        0.5913394901m, -0.548311967m, -0.5913303597m, 0, 0.1204873514m, -0.7626472379m, -0.6354935001m, 0, 0.616959265m, 0.03079647928m, 0.7863922953m, 0, 0.1258156836m, -0.6640829889m, -0.7369967419m, 0, -0.6477565124m, -0.1740147258m, -0.7417077429m, 0, 0.6217889313m, -0.7804430448m, -0.06547655076m, 0, 0.6589943422m, -0.6096987708m, 0.4404473475m, 0, -0.2689837504m, -0.6732403169m, -0.6887635427m, 0,
        -0.3849775103m, 0.5676542638m, 0.7277093879m, 0, 0.5754444408m, 0.8110471154m, -0.1051963504m, 0, 0.9141593684m, 0.3832947817m, 0.131900567m, 0, -0.107925319m, 0.9245493968m, 0.3654593525m, 0, 0.377977089m, 0.3043148782m, 0.8743716458m, 0, -0.2142885215m, -0.8259286236m, 0.5214617324m, 0, 0.5802544474m, 0.4148098596m, -0.7008834116m, 0, -0.1982660881m, 0.8567161266m, -0.4761596756m, 0,
        -0.03381553704m, 0.3773180787m, -0.9254661404m, 0, -0.6867922841m, -0.6656597827m, 0.2919133642m, 0, 0.7731742607m, -0.2875793547m, -0.5652430251m, 0, -0.09655941928m, 0.9193708367m, -0.3813575004m, 0, 0.2715702457m, -0.9577909544m, -0.09426605581m, 0, 0.2451015704m, -0.6917998565m, -0.6792188003m, 0, 0.977700782m, -0.1753855374m, 0.1155036542m, 0, -0.5224739938m, 0.8521606816m, 0.02903615945m, 0,
        -0.7734880599m, -0.5261292347m, 0.3534179531m, 0, -0.7134492443m, -0.269547243m, 0.6467878011m, 0, 0.1644037271m, 0.5105846203m, -0.8439637196m, 0, 0.6494635788m, 0.05585611296m, 0.7583384168m, 0, -0.4711970882m, 0.5017280509m, -0.7254255765m, 0, -0.6335764307m, -0.2381686273m, -0.7361091029m, 0, -0.9021533097m, -0.270947803m, -0.3357181763m, 0, -0.3793711033m, 0.872258117m, 0.3086152025m, 0,
        -0.6855598966m, -0.3250143309m, 0.6514394162m, 0, 0.2900942212m, -0.7799057743m, -0.5546100667m, 0, -0.2098319339m, 0.85037073m, 0.4825351604m, 0, -0.4592603758m, 0.6598504336m, -0.5947077538m, 0, 0.8715945488m, 0.09616365406m, -0.4807031248m, 0, -0.6776666319m, 0.7118504878m, -0.1844907016m, 0, 0.7044377633m, 0.312427597m, 0.637304036m, 0, -0.7052318886m, -0.2401093292m, -0.6670798253m, 0,
        0.081921007m, -0.7207336136m, -0.6883545647m, 0, -0.6993680906m, -0.5875763221m, -0.4069869034m, 0, -0.1281454481m, 0.6419895885m, 0.7559286424m, 0, -0.6337388239m, -0.6785471501m, -0.3714146849m, 0, 0.5565051903m, -0.2168887573m, -0.8020356851m, 0, -0.5791554484m, 0.7244372011m, -0.3738578718m, 0, 0.1175779076m, -0.7096451073m, 0.6946792478m, 0, -0.6134619607m, 0.1323631078m, 0.7785527795m, 0,
        0.6984635305m, -0.02980516237m, -0.715024719m, 0, 0.8318082963m, -0.3930171956m, 0.3919597455m, 0, 0.1469576422m, 0.05541651717m, -0.9875892167m, 0, 0.708868575m, -0.2690503865m, 0.6520101478m, 0, 0.2726053183m, 0.67369766m, -0.68688995m, 0, -0.6591295371m, 0.3035458599m, -0.6880466294m, 0, 0.4815131379m, -0.7528270071m, 0.4487723203m, 0, 0.9430009463m, 0.1675647412m, -0.2875261255m, 0,
        0.434802957m, 0.7695304522m, -0.4677277752m, 0, 0.3931996188m, 0.594473625m, 0.7014236729m, 0, 0.7254336655m, -0.603925654m, 0.3301814672m, 0, 0.7590235227m, -0.6506083235m, 0.02433313207m, 0, -0.8552768592m, -0.3430042733m, 0.3883935666m, 0, -0.6139746835m, 0.6981725247m, 0.3682257648m, 0, -0.7465905486m, -0.5752009504m, 0.3342849376m, 0, 0.5730065677m, 0.810555537m, -0.1210916791m, 0,
        -0.9225877367m, -0.3475211012m, -0.167514036m, 0, -0.7105816789m, -0.4719692027m, -0.5218416899m, 0, -0.08564609717m, 0.3583001386m, 0.929669703m, 0, -0.8279697606m, -0.2043157126m, 0.5222271202m, 0, 0.427944023m, 0.278165994m, 0.8599346446m, 0, 0.5399079671m, -0.7857120652m, -0.3019204161m, 0, 0.5678404253m, -0.5495413974m, -0.6128307303m, 0, -0.9896071041m, 0.1365639107m, -0.04503418428m, 0,
        -0.6154342638m, -0.6440875597m, 0.4543037336m, 0, 0.1074204368m, -0.7946340692m, 0.5975094525m, 0, -0.3595449969m, -0.8885529948m, 0.28495784m, 0, -0.2180405296m, 0.1529888965m, 0.9638738118m, 0, -0.7277432317m, -0.6164050508m, -0.3007234646m, 0, 0.7249729114m, -0.00669719484m, 0.6887448187m, 0, -0.5553659455m, -0.5336586252m, 0.6377908264m, 0, 0.5137558015m, 0.7976208196m, -0.3160000073m, 0,
        -0.3794024848m, 0.9245608561m, -0.03522751494m, 0, 0.8229248658m, 0.2745365933m, -0.4974176556m, 0, -0.5404114394m, 0.6091141441m, 0.5804613989m, 0, 0.8036581901m, -0.2703029469m, 0.5301601931m, 0, 0.6044318879m, 0.6832968393m, 0.4095943388m, 0, 0.06389988817m, 0.9658208605m, -0.2512108074m, 0, 0.1087113286m, 0.7402471173m, -0.6634877936m, 0, -0.713427712m, -0.6926784018m, 0.1059128479m, 0,
        0.6458897819m, -0.5724548511m, -0.5050958653m, 0, -0.6553931414m, 0.7381471625m, 0.159995615m, 0, 0.3910961323m, 0.9188871375m, -0.05186755998m, 0, -0.4879022471m, -0.5904376907m, 0.6429111375m, 0, 0.6014790094m, 0.7707441366m, -0.2101820095m, 0, -0.5677173047m, 0.7511360995m, 0.3368851762m, 0, 0.7858573506m, 0.226674665m, 0.5753666838m, 0, -0.4520345543m, -0.604222686m, -0.6561857263m, 0,
        0.002272116345m, 0.4132844051m, -0.9105991643m, 0, -0.5815751419m, -0.5162925989m, 0.6286591339m, 0, -0.03703704785m, 0.8273785755m, 0.5604221175m, 0, -0.5119692504m, 0.7953543429m, -0.3244980058m, 0, -0.2682417366m, -0.9572290247m, -0.1084387619m, 0, -0.2322482736m, -0.9679131102m, -0.09594243324m, 0, 0.3554328906m, -0.8881505545m, 0.2913006227m, 0, 0.7346520519m, -0.4371373164m, 0.5188422971m, 0,
        0.9985120116m, 0.04659011161m, -0.02833944577m, 0, -0.3727687496m, -0.9082481361m, 0.1900757285m, 0, 0.91737377m, -0.3483642108m, 0.1925298489m, 0, 0.2714911074m, 0.4147529736m, -0.8684886582m, 0, 0.5131763485m, -0.7116334161m, 0.4798207128m, 0, -0.8737353606m, 0.18886992m, -0.4482350644m, 0, 0.8460043821m, -0.3725217914m, 0.3814499973m, 0, 0.8978727456m, -0.1780209141m, -0.4026575304m, 0,
        0.2178065647m, -0.9698322841m, -0.1094789531m, 0, -0.1518031304m, -0.7788918132m, -0.6085091231m, 0, -0.2600384876m, -0.4755398075m, -0.8403819825m, 0, 0.572313509m, -0.7474340931m, -0.3373418503m, 0, -0.7174141009m, 0.1699017182m, -0.6756111411m, 0, -0.684180784m, 0.02145707593m, -0.7289967412m, 0, -0.2007447902m, 0.06555605789m, -0.9774476623m, 0, -0.1148803697m, -0.8044887315m, 0.5827524187m, 0,
        -0.7870349638m, 0.03447489231m, 0.6159443543m, 0, -0.2015596421m, 0.6859872284m, 0.6991389226m, 0, -0.08581082512m, -0.10920836m, -0.9903080513m, 0, 0.5532693395m, 0.7325250401m, -0.396610771m, 0, -0.1842489331m, -0.9777375055m, -0.1004076743m, 0, 0.0775473789m, -0.9111505856m, 0.4047110257m, 0, 0.1399838409m, 0.7601631212m, -0.6344734459m, 0, 0.4484419361m, -0.845289248m, 0.2904925424m, 0
    };


        [MethodImpl(INLINE)]
        private static decimal FastMin(decimal a, decimal b) { return a < b ? a : b; }

        [MethodImpl(INLINE)]
        private static decimal FastMax(decimal a, decimal b) { return a > b ? a : b; }

        [MethodImpl(INLINE)]
        private static decimal FastAbs(decimal f) { return f < 0 ? -f : f; }

        [MethodImpl(INLINE)]
        private static decimal FastSqrt(decimal f) { return (decimal)Math.Sqrt((double)f); }

        [MethodImpl(INLINE)]
        private static int FastFloor(FNLdecimal f) { return f >= 0 ? (int)f : (int)f - 1; }

        [MethodImpl(INLINE)]
        private static int FastRound(FNLdecimal f) { return f >= 0 ? (int)(f + 0.5m) : (int)(f - 0.5m); }

        [MethodImpl(INLINE)]
        private static decimal Lerp(decimal a, decimal b, decimal t) { return a + t * (b - a); }

        [MethodImpl(INLINE)]
        private static decimal InterpHermite(decimal t) { return t * t * (3 - 2 * t); }

        [MethodImpl(INLINE)]
        private static decimal InterpQuintic(decimal t) { return t * t * t * (t * (t * 6 - 15) + 10); }

        [MethodImpl(INLINE)]
        private static decimal CubicLerp(decimal a, decimal b, decimal c, decimal d, decimal t)
        {
            decimal p = d - c - (a - b);
            return t * t * t * p + t * t * (a - b - p) + t * (c - a) + b;
        }

        [MethodImpl(INLINE)]
        private static decimal PingPong(decimal t)
        {
            t -= (int)(t * 0.5m) * 2;
            return t < 1 ? t : 2 - t;
        }

        private void CalculateFractalBounding()
        {
            decimal gain = FastAbs(mGain);
            decimal amp = gain;
            decimal ampFractal = 1.0m;
            for (int i = 1; i < mOctaves; i++)
            {
                ampFractal += amp;
                amp *= gain;
            }
            mFractalBounding = 1 / ampFractal;
        }

        // Hashing
        private const int PrimeX = 501125321;
        private const int PrimeY = 1136930381;
        private const int PrimeZ = 1720413743;

        [MethodImpl(INLINE)]
        private static int Hash(int seed, int xPrimed, int yPrimed)
        {
            int hash = seed ^ xPrimed ^ yPrimed;

            hash *= 0x27d4eb2d;
            return hash;
        }

        [MethodImpl(INLINE)]
        private static int Hash(int seed, int xPrimed, int yPrimed, int zPrimed)
        {
            int hash = seed ^ xPrimed ^ yPrimed ^ zPrimed;

            hash *= 0x27d4eb2d;
            return hash;
        }

        [MethodImpl(INLINE)]
        private static decimal ValCoord(int seed, int xPrimed, int yPrimed)
        {
            int hash = Hash(seed, xPrimed, yPrimed);

            hash *= hash;
            hash ^= hash << 19;
            return hash * (1 / 2147483648.0m);
        }

        [MethodImpl(INLINE)]
        private static decimal ValCoord(int seed, int xPrimed, int yPrimed, int zPrimed)
        {
            int hash = Hash(seed, xPrimed, yPrimed, zPrimed);

            hash *= hash;
            hash ^= hash << 19;
            return hash * (1 / 2147483648.0m);
        }

        [MethodImpl(INLINE)]
        private static decimal GradCoord(int seed, int xPrimed, int yPrimed, decimal xd, decimal yd)
        {
            int hash = Hash(seed, xPrimed, yPrimed);
            hash ^= hash >> 15;
            hash &= 127 << 1;

            decimal xg = Gradients2D[hash];
            decimal yg = Gradients2D[hash | 1];

            return xd * xg + yd * yg;
        }

        [MethodImpl(INLINE)]
        private static decimal GradCoord(int seed, int xPrimed, int yPrimed, int zPrimed, decimal xd, decimal yd, decimal zd)
        {
            int hash = Hash(seed, xPrimed, yPrimed, zPrimed);
            hash ^= hash >> 15;
            hash &= 63 << 2;

            decimal xg = Gradients3D[hash];
            decimal yg = Gradients3D[hash | 1];
            decimal zg = Gradients3D[hash | 2];

            return xd * xg + yd * yg + zd * zg;
        }

        [MethodImpl(INLINE)]
        private static void GradCoordOut(int seed, int xPrimed, int yPrimed, out decimal xo, out decimal yo)
        {
            int hash = Hash(seed, xPrimed, yPrimed) & 255 << 1;

            xo = RandVecs2D[hash];
            yo = RandVecs2D[hash | 1];
        }

        [MethodImpl(INLINE)]
        private static void GradCoordOut(int seed, int xPrimed, int yPrimed, int zPrimed, out decimal xo, out decimal yo, out decimal zo)
        {
            int hash = Hash(seed, xPrimed, yPrimed, zPrimed) & 255 << 2;

            xo = RandVecs3D[hash];
            yo = RandVecs3D[hash | 1];
            zo = RandVecs3D[hash | 2];
        }

        [MethodImpl(INLINE)]
        private static void GradCoordDual(int seed, int xPrimed, int yPrimed, decimal xd, decimal yd, out decimal xo, out decimal yo)
        {
            int hash = Hash(seed, xPrimed, yPrimed);
            int index1 = hash & 127 << 1;
            int index2 = hash >> 7 & 255 << 1;

            decimal xg = Gradients2D[index1];
            decimal yg = Gradients2D[index1 | 1];
            decimal value = xd * xg + yd * yg;

            decimal xgo = RandVecs2D[index2];
            decimal ygo = RandVecs2D[index2 | 1];

            xo = value * xgo;
            yo = value * ygo;
        }

        [MethodImpl(INLINE)]
        private static void GradCoordDual(int seed, int xPrimed, int yPrimed, int zPrimed, decimal xd, decimal yd, decimal zd, out decimal xo, out decimal yo, out decimal zo)
        {
            int hash = Hash(seed, xPrimed, yPrimed, zPrimed);
            int index1 = hash & 63 << 2;
            int index2 = hash >> 6 & 255 << 2;

            decimal xg = Gradients3D[index1];
            decimal yg = Gradients3D[index1 | 1];
            decimal zg = Gradients3D[index1 | 2];
            decimal value = xd * xg + yd * yg + zd * zg;

            decimal xgo = RandVecs3D[index2];
            decimal ygo = RandVecs3D[index2 | 1];
            decimal zgo = RandVecs3D[index2 | 2];

            xo = value * xgo;
            yo = value * ygo;
            zo = value * zgo;
        }


        // Generic noise gen

        private decimal GenNoiseSingle(int seed, FNLdecimal x, FNLdecimal y)
        {
            return mNoiseType switch
            {
                NoiseType.OpenSimplex2 => SingleSimplex(seed, x, y),
                NoiseType.OpenSimplex2S => SingleOpenSimplex2S(seed, x, y),
                NoiseType.Cellular => SingleCellular(seed, x, y),
                NoiseType.Perlin => SinglePerlin(seed, x, y),
                NoiseType.ValueCubic => SingleValueCubic(seed, x, y),
                NoiseType.Value => SingleValue(seed, x, y),
                _ => 0,
            };
        }

        private decimal GenNoiseSingle(int seed, FNLdecimal x, FNLdecimal y, FNLdecimal z)
        {
            return mNoiseType switch
            {
                NoiseType.OpenSimplex2 => SingleOpenSimplex2(seed, x, y, z),
                NoiseType.OpenSimplex2S => SingleOpenSimplex2S(seed, x, y, z),
                NoiseType.Cellular => SingleCellular(seed, x, y, z),
                NoiseType.Perlin => SinglePerlin(seed, x, y, z),
                NoiseType.ValueCubic => SingleValueCubic(seed, x, y, z),
                NoiseType.Value => SingleValue(seed, x, y, z),
                _ => 0,
            };
        }


        // Noise Coordinate Transforms (frequency, and possible skew or rotation)

        [MethodImpl(INLINE)]
        private void TransformNoiseCoordinate(ref FNLdecimal x, ref FNLdecimal y)
        {
            x *= mFrequency;
            y *= mFrequency;

            switch (mNoiseType)
            {
                case NoiseType.OpenSimplex2:
                case NoiseType.OpenSimplex2S:
                    {
                        const FNLdecimal SQRT3 = (FNLdecimal)1.7320508075688772935274463415059;
                        const FNLdecimal F2 = 0.5m * (SQRT3 - 1);
                        FNLdecimal t = (x + y) * F2;
                        x += t;
                        y += t;
                    }
                    break;
                default:
                    break;
            }
        }

        [MethodImpl(INLINE)]
        private void TransformNoiseCoordinate(ref FNLdecimal x, ref FNLdecimal y, ref FNLdecimal z)
        {
            x *= mFrequency;
            y *= mFrequency;
            z *= mFrequency;

            switch (mTransformType3D)
            {
                case TransformType3D.ImproveXYPlanes:
                    {
                        FNLdecimal xy = x + y;
                        FNLdecimal s2 = xy * -(FNLdecimal)0.211324865405187;
                        z *= (FNLdecimal)0.577350269189626;
                        x += s2 - z;
                        y = y + s2 - z;
                        z += xy * (FNLdecimal)0.577350269189626;
                    }
                    break;
                case TransformType3D.ImproveXZPlanes:
                    {
                        FNLdecimal xz = x + z;
                        FNLdecimal s2 = xz * -(FNLdecimal)0.211324865405187;
                        y *= (FNLdecimal)0.577350269189626;
                        x += s2 - y;
                        z += s2 - y;
                        y += xz * (FNLdecimal)0.577350269189626;
                    }
                    break;
                case TransformType3D.DefaultOpenSimplex2:
                    {
                        const FNLdecimal R3 = (FNLdecimal)(2.0 / 3.0);
                        FNLdecimal r = (x + y + z) * R3; // Rotation, not skew
                        x = r - x;
                        y = r - y;
                        z = r - z;
                    }
                    break;
                default:
                    break;
            }
        }

        private void UpdateTransformType3D()
        {
            mTransformType3D = mRotationType3D switch
            {
                RotationType3D.ImproveXYPlanes => TransformType3D.ImproveXYPlanes,
                RotationType3D.ImproveXZPlanes => TransformType3D.ImproveXZPlanes,
                _ => mNoiseType switch
                {
                    NoiseType.OpenSimplex2 or NoiseType.OpenSimplex2S => TransformType3D.DefaultOpenSimplex2,
                    _ => TransformType3D.None,
                },
            };
        }


        // Domain Warp Coordinate Transforms

        [MethodImpl(INLINE)]
        private void TransformDomainWarpCoordinate(ref FNLdecimal x, ref FNLdecimal y)
        {
            switch (mDomainWarpType)
            {
                case DomainWarpType.OpenSimplex2:
                case DomainWarpType.OpenSimplex2Reduced:
                    {
                        const FNLdecimal SQRT3 = (FNLdecimal)1.7320508075688772935274463415059;
                        const FNLdecimal F2 = 0.5m * (SQRT3 - 1);
                        FNLdecimal t = (x + y) * F2;
                        x += t; y += t;
                    }
                    break;
                default:
                    break;
            }
        }

        [MethodImpl(INLINE)]
        private void TransformDomainWarpCoordinate(ref FNLdecimal x, ref FNLdecimal y, ref FNLdecimal z)
        {
            switch (mWarpTransformType3D)
            {
                case TransformType3D.ImproveXYPlanes:
                    {
                        FNLdecimal xy = x + y;
                        FNLdecimal s2 = xy * -(FNLdecimal)0.211324865405187;
                        z *= (FNLdecimal)0.577350269189626;
                        x += s2 - z;
                        y = y + s2 - z;
                        z += xy * (FNLdecimal)0.577350269189626;
                    }
                    break;
                case TransformType3D.ImproveXZPlanes:
                    {
                        FNLdecimal xz = x + z;
                        FNLdecimal s2 = xz * -(FNLdecimal)0.211324865405187;
                        y *= (FNLdecimal)0.577350269189626;
                        x += s2 - y; z += s2 - y;
                        y += xz * (FNLdecimal)0.577350269189626;
                    }
                    break;
                case TransformType3D.DefaultOpenSimplex2:
                    {
                        const FNLdecimal R3 = (FNLdecimal)(2.0 / 3.0);
                        FNLdecimal r = (x + y + z) * R3; // Rotation, not skew
                        x = r - x;
                        y = r - y;
                        z = r - z;
                    }
                    break;
                default:
                    break;
            }
        }

        private void UpdateWarpTransformType3D()
        {
            mWarpTransformType3D = mRotationType3D switch
            {
                RotationType3D.ImproveXYPlanes => TransformType3D.ImproveXYPlanes,
                RotationType3D.ImproveXZPlanes => TransformType3D.ImproveXZPlanes,
                _ => mDomainWarpType switch
                {
                    DomainWarpType.OpenSimplex2 or DomainWarpType.OpenSimplex2Reduced => TransformType3D.DefaultOpenSimplex2,
                    _ => TransformType3D.None,
                },
            };
        }


        // Fractal FBm

        private decimal GenFractalFBm(FNLdecimal x, FNLdecimal y)
        {
            int seed = mSeed;
            decimal sum = 0;
            decimal amp = mFractalBounding;

            for (int i = 0; i < mOctaves; i++)
            {
                decimal noise = GenNoiseSingle(seed++, x, y);
                sum += noise * amp;
                amp *= Lerp(1.0m, FastMin(noise + 1, 2) * 0.5m, mWeightedStrength);

                x *= mLacunarity;
                y *= mLacunarity;
                amp *= mGain;
            }

            return sum;
        }

        private decimal GenFractalFBm(FNLdecimal x, FNLdecimal y, FNLdecimal z)
        {
            int seed = mSeed;
            decimal sum = 0;
            decimal amp = mFractalBounding;

            for (int i = 0; i < mOctaves; i++)
            {
                decimal noise = GenNoiseSingle(seed++, x, y, z);
                sum += noise * amp;
                amp *= Lerp(1.0m, (noise + 1) * 0.5m, mWeightedStrength);

                x *= mLacunarity;
                y *= mLacunarity;
                z *= mLacunarity;
                amp *= mGain;
            }

            return sum;
        }


        // Fractal Ridged

        private decimal GenFractalRidged(FNLdecimal x, FNLdecimal y)
        {
            int seed = mSeed;
            decimal sum = 0;
            decimal amp = mFractalBounding;

            for (int i = 0; i < mOctaves; i++)
            {
                decimal noise = FastAbs(GenNoiseSingle(seed++, x, y));
                sum += (noise * -2 + 1) * amp;
                amp *= Lerp(1.0m, 1 - noise, mWeightedStrength);

                x *= mLacunarity;
                y *= mLacunarity;
                amp *= mGain;
            }

            return sum;
        }

        private decimal GenFractalRidged(FNLdecimal x, FNLdecimal y, FNLdecimal z)
        {
            int seed = mSeed;
            decimal sum = 0;
            decimal amp = mFractalBounding;

            for (int i = 0; i < mOctaves; i++)
            {
                decimal noise = FastAbs(GenNoiseSingle(seed++, x, y, z));
                sum += (noise * -2 + 1) * amp;
                amp *= Lerp(1.0m, 1 - noise, mWeightedStrength);

                x *= mLacunarity;
                y *= mLacunarity;
                z *= mLacunarity;
                amp *= mGain;
            }

            return sum;
        }


        // Fractal PingPong 

        private decimal GenFractalPingPong(FNLdecimal x, FNLdecimal y)
        {
            int seed = mSeed;
            decimal sum = 0;
            decimal amp = mFractalBounding;

            for (int i = 0; i < mOctaves; i++)
            {
                decimal noise = PingPong((GenNoiseSingle(seed++, x, y) + 1) * mPingPongStrength);
                sum += (noise - 0.5m) * 2 * amp;
                amp *= Lerp(1.0m, noise, mWeightedStrength);

                x *= mLacunarity;
                y *= mLacunarity;
                amp *= mGain;
            }

            return sum;
        }

        private decimal GenFractalPingPong(FNLdecimal x, FNLdecimal y, FNLdecimal z)
        {
            int seed = mSeed;
            decimal sum = 0;
            decimal amp = mFractalBounding;

            for (int i = 0; i < mOctaves; i++)
            {
                decimal noise = PingPong((GenNoiseSingle(seed++, x, y, z) + 1) * mPingPongStrength);
                sum += (noise - 0.5m) * 2 * amp;
                amp *= Lerp(1.0m, noise, mWeightedStrength);

                x *= mLacunarity;
                y *= mLacunarity;
                z *= mLacunarity;
                amp *= mGain;
            }

            return sum;
        }


        // Simplex/OpenSimplex2 Noise

        private static decimal SingleSimplex(int seed, FNLdecimal x, FNLdecimal y)
        {
            // 2D OpenSimplex2 case uses the same algorithm as ordinary Simplex.

            const decimal SQRT3 = 1.7320508075688772935274463415059m;
            const decimal G2 = (3 - SQRT3) / 6;

            /*
             * --- Skew moved to TransformNoiseCoordinate method ---
             * const FNdecimal F2 = 0.5m * (SQRT3 - 1);
             * FNdecimal s = (x + y) * F2;
             * x += s; y += s;
            */

            int i = FastFloor(x);
            int j = FastFloor(y);
            decimal xi = x - i;
            decimal yi = y - j;

            decimal t = (xi + yi) * G2;
            decimal x0 = xi - t;
            decimal y0 = yi - t;

            i *= PrimeX;
            j *= PrimeY;

            decimal n0, n1, n2;

            decimal a = 0.5m - x0 * x0 - y0 * y0;
            if (a <= 0) n0 = 0;
            else
            {
                n0 = a * a * a * a * GradCoord(seed, i, j, x0, y0);
            }

            decimal c = 2 * (1 - 2 * G2) * (1 / G2 - 2) * t + -2 * (1 - 2 * G2) * (1 - 2 * G2) + a;
            if (c <= 0) n2 = 0;
            else
            {
                decimal x2 = x0 + (2 * G2 - 1);
                decimal y2 = y0 + (2 * G2 - 1);
                n2 = c * c * c * c * GradCoord(seed, i + PrimeX, j + PrimeY, x2, y2);
            }

            if (y0 > x0)
            {
                decimal x1 = x0 + G2;
                decimal y1 = y0 + (G2 - 1);
                decimal b = 0.5m - x1 * x1 - y1 * y1;
                if (b <= 0) n1 = 0;
                else
                {
                    n1 = b * b * b * b * GradCoord(seed, i, j + PrimeY, x1, y1);
                }
            }
            else
            {
                decimal x1 = x0 + (G2 - 1);
                decimal y1 = y0 + G2;
                decimal b = 0.5m - x1 * x1 - y1 * y1;
                if (b <= 0) n1 = 0;
                else
                {
                    n1 = b * b * b * b * GradCoord(seed, i + PrimeX, j, x1, y1);
                }
            }

            return (n0 + n1 + n2) * 99.83685446303647m;
        }

        private static decimal SingleOpenSimplex2(int seed, FNLdecimal x, FNLdecimal y, FNLdecimal z)
        {
            // 3D OpenSimplex2 case uses two offset rotated cube grids.

            /*
             * --- Rotation moved to TransformNoiseCoordinate method ---
             * const FNdecimal R3 = (FNdecimal)(2.0 / 3.0);
             * FNdecimal r = (x + y + z) * R3; // Rotation, not skew
             * x = r - x; y = r - y; z = r - z;
            */

            int i = FastRound(x);
            int j = FastRound(y);
            int k = FastRound(z);
            decimal x0 = x - i;
            decimal y0 = y - j;
            decimal z0 = z - k;

            int xNSign = (int)(-1.0m - x0) | 1;
            int yNSign = (int)(-1.0m - y0) | 1;
            int zNSign = (int)(-1.0m - z0) | 1;

            decimal ax0 = xNSign * -x0;
            decimal ay0 = yNSign * -y0;
            decimal az0 = zNSign * -z0;

            i *= PrimeX;
            j *= PrimeY;
            k *= PrimeZ;

            decimal value = 0;
            decimal a = 0.6m - x0 * x0 - (y0 * y0 + z0 * z0);

            for (int l = 0; ; l++)
            {
                if (a > 0)
                {
                    value += a * a * a * a * GradCoord(seed, i, j, k, x0, y0, z0);
                }

                if (ax0 >= ay0 && ax0 >= az0)
                {
                    decimal b = a + ax0 + ax0;
                    if (b > 1)
                    {
                        b -= 1;
                        value += b * b * b * b * GradCoord(seed, i - xNSign * PrimeX, j, k, x0 + xNSign, y0, z0);
                    }
                }
                else if (ay0 > ax0 && ay0 >= az0)
                {
                    decimal b = a + ay0 + ay0;
                    if (b > 1)
                    {
                        b -= 1;
                        value += b * b * b * b * GradCoord(seed, i, j - yNSign * PrimeY, k, x0, y0 + yNSign, z0);
                    }
                }
                else
                {
                    decimal b = a + az0 + az0;
                    if (b > 1)
                    {
                        b -= 1;
                        value += b * b * b * b * GradCoord(seed, i, j, k - zNSign * PrimeZ, x0, y0, z0 + zNSign);
                    }
                }

                if (l == 1) break;

                ax0 = 0.5m - ax0;
                ay0 = 0.5m - ay0;
                az0 = 0.5m - az0;

                x0 = xNSign * ax0;
                y0 = yNSign * ay0;
                z0 = zNSign * az0;

                a += 0.75m - ax0 - (ay0 + az0);

                i += xNSign >> 1 & PrimeX;
                j += yNSign >> 1 & PrimeY;
                k += zNSign >> 1 & PrimeZ;

                xNSign = -xNSign;
                yNSign = -yNSign;
                zNSign = -zNSign;

                seed = ~seed;
            }

            return value * 32.69428253173828125m;
        }


        // OpenSimplex2S Noise

        private static decimal SingleOpenSimplex2S(int seed, FNLdecimal x, FNLdecimal y)
        {
            // 2D OpenSimplex2S case is a modified 2D simplex noise.

            const FNLdecimal SQRT3 = (FNLdecimal)1.7320508075688772935274463415059;
            const FNLdecimal G2 = (3 - SQRT3) / 6;

            /*
             * --- Skew moved to TransformNoiseCoordinate method ---
             * const FNdecimal F2 = 0.5m * (SQRT3 - 1);
             * FNdecimal s = (x + y) * F2;
             * x += s; y += s;
            */

            int i = FastFloor(x);
            int j = FastFloor(y);
            decimal xi = x - i;
            decimal yi = y - j;

            i *= PrimeX;
            j *= PrimeY;
            int i1 = i + PrimeX;
            int j1 = j + PrimeY;

            decimal t = (xi + yi) * G2;
            decimal x0 = xi - t;
            decimal y0 = yi - t;

            decimal a0 = 2.0m / 3.0m - x0 * x0 - y0 * y0;
            decimal value = a0 * a0 * a0 * a0 * GradCoord(seed, i, j, x0, y0);

            decimal a1 = 2 * (1 - 2 * G2) * (1 / G2 - 2) * t + -2 * (1 - 2 * G2) * (1 - 2 * G2) + a0;
            decimal x1 = x0 - (1 - 2 * G2);
            decimal y1 = y0 - (1 - 2 * G2);
            value += a1 * a1 * a1 * a1 * GradCoord(seed, i1, j1, x1, y1);

            // Nested conditionals were faster than compact bit logic/arithmetic.
            decimal xmyi = xi - yi;
            if (t > G2)
            {
                if (xi + xmyi > 1)
                {
                    decimal x2 = x0 + (3 * G2 - 2);
                    decimal y2 = y0 + (3 * G2 - 1);
                    decimal a2 = 2.0m / 3.0m - x2 * x2 - y2 * y2;
                    if (a2 > 0)
                    {
                        value += a2 * a2 * a2 * a2 * GradCoord(seed, i + (PrimeX << 1), j + PrimeY, x2, y2);
                    }
                }
                else
                {
                    decimal x2 = x0 + G2;
                    decimal y2 = y0 + (G2 - 1);
                    decimal a2 = 2.0m / 3.0m - x2 * x2 - y2 * y2;
                    if (a2 > 0)
                    {
                        value += a2 * a2 * a2 * a2 * GradCoord(seed, i, j + PrimeY, x2, y2);
                    }
                }

                if (yi - xmyi > 1)
                {
                    decimal x3 = x0 + (3 * G2 - 1);
                    decimal y3 = y0 + (3 * G2 - 2);
                    decimal a3 = 2.0m / 3.0m - x3 * x3 - y3 * y3;
                    if (a3 > 0)
                    {
                        value += a3 * a3 * a3 * a3 * GradCoord(seed, i + PrimeX, j + (PrimeY << 1), x3, y3);
                    }
                }
                else
                {
                    decimal x3 = x0 + (G2 - 1);
                    decimal y3 = y0 + G2;
                    decimal a3 = 2.0m / 3.0m - x3 * x3 - y3 * y3;
                    if (a3 > 0)
                    {
                        value += a3 * a3 * a3 * a3 * GradCoord(seed, i + PrimeX, j, x3, y3);
                    }
                }
            }
            else
            {
                if (xi + xmyi < 0)
                {
                    decimal x2 = x0 + (1 - G2);
                    decimal y2 = y0 - G2;
                    decimal a2 = 2.0m / 3.0m - x2 * x2 - y2 * y2;
                    if (a2 > 0)
                    {
                        value += a2 * a2 * a2 * a2 * GradCoord(seed, i - PrimeX, j, x2, y2);
                    }
                }
                else
                {
                    decimal x2 = x0 + (G2 - 1);
                    decimal y2 = y0 + G2;
                    decimal a2 = 2.0m / 3.0m - x2 * x2 - y2 * y2;
                    if (a2 > 0)
                    {
                        value += a2 * a2 * a2 * a2 * GradCoord(seed, i + PrimeX, j, x2, y2);
                    }
                }

                if (yi < xmyi)
                {
                    decimal x2 = x0 - G2;
                    decimal y2 = y0 - (G2 - 1);
                    decimal a2 = 2.0m / 3.0m - x2 * x2 - y2 * y2;
                    if (a2 > 0)
                    {
                        value += a2 * a2 * a2 * a2 * GradCoord(seed, i, j - PrimeY, x2, y2);
                    }
                }
                else
                {
                    decimal x2 = x0 + G2;
                    decimal y2 = y0 + (G2 - 1);
                    decimal a2 = 2.0m / 3.0m - x2 * x2 - y2 * y2;
                    if (a2 > 0)
                    {
                        value += a2 * a2 * a2 * a2 * GradCoord(seed, i, j + PrimeY, x2, y2);
                    }
                }
            }

            return value * 18.24196194486065m;
        }

        private static decimal SingleOpenSimplex2S(int seed, FNLdecimal x, FNLdecimal y, FNLdecimal z)
        {
            // 3D OpenSimplex2S case uses two offset rotated cube grids.

            /*
             * --- Rotation moved to TransformNoiseCoordinate method ---
             * const FNdecimal R3 = (FNdecimal)(2.0 / 3.0);
             * FNdecimal r = (x + y + z) * R3; // Rotation, not skew
             * x = r - x; y = r - y; z = r - z;
            */

            int i = FastFloor(x);
            int j = FastFloor(y);
            int k = FastFloor(z);
            decimal xi = x - i;
            decimal yi = y - j;
            decimal zi = z - k;

            i *= PrimeX;
            j *= PrimeY;
            k *= PrimeZ;
            int seed2 = seed + 1293373;

            int xNMask = (int)(-0.5m - xi);
            int yNMask = (int)(-0.5m - yi);
            int zNMask = (int)(-0.5m - zi);

            decimal x0 = xi + xNMask;
            decimal y0 = yi + yNMask;
            decimal z0 = zi + zNMask;
            decimal a0 = 0.75m - x0 * x0 - y0 * y0 - z0 * z0;
            decimal value = a0 * a0 * a0 * a0 * GradCoord(seed,
                i + (xNMask & PrimeX), j + (yNMask & PrimeY), k + (zNMask & PrimeZ), x0, y0, z0);

            decimal x1 = xi - 0.5m;
            decimal y1 = yi - 0.5m;
            decimal z1 = zi - 0.5m;
            decimal a1 = 0.75m - x1 * x1 - y1 * y1 - z1 * z1;
            value += a1 * a1 * a1 * a1 * GradCoord(seed2,
                i + PrimeX, j + PrimeY, k + PrimeZ, x1, y1, z1);

            decimal xAFlipMask0 = ((xNMask | 1) << 1) * x1;
            decimal yAFlipMask0 = ((yNMask | 1) << 1) * y1;
            decimal zAFlipMask0 = ((zNMask | 1) << 1) * z1;
            decimal xAFlipMask1 = (-2 - (xNMask << 2)) * x1 - 1.0m;
            decimal yAFlipMask1 = (-2 - (yNMask << 2)) * y1 - 1.0m;
            decimal zAFlipMask1 = (-2 - (zNMask << 2)) * z1 - 1.0m;

            bool skip5 = false;
            decimal a2 = xAFlipMask0 + a0;
            if (a2 > 0)
            {
                decimal x2 = x0 - (xNMask | 1);
                decimal y2 = y0;
                decimal z2 = z0;
                value += a2 * a2 * a2 * a2 * GradCoord(seed,
                    i + (~xNMask & PrimeX), j + (yNMask & PrimeY), k + (zNMask & PrimeZ), x2, y2, z2);
            }
            else
            {
                decimal a3 = yAFlipMask0 + zAFlipMask0 + a0;
                if (a3 > 0)
                {
                    decimal x3 = x0;
                    decimal y3 = y0 - (yNMask | 1);
                    decimal z3 = z0 - (zNMask | 1);
                    value += a3 * a3 * a3 * a3 * GradCoord(seed,
                        i + (xNMask & PrimeX), j + (~yNMask & PrimeY), k + (~zNMask & PrimeZ), x3, y3, z3);
                }

                decimal a4 = xAFlipMask1 + a1;
                if (a4 > 0)
                {
                    decimal x4 = (xNMask | 1) + x1;
                    decimal y4 = y1;
                    decimal z4 = z1;
                    value += a4 * a4 * a4 * a4 * GradCoord(seed2,
                        i + (xNMask & PrimeX * 2), j + PrimeY, k + PrimeZ, x4, y4, z4);
                    skip5 = true;
                }
            }

            bool skip9 = false;
            decimal a6 = yAFlipMask0 + a0;
            if (a6 > 0)
            {
                decimal x6 = x0;
                decimal y6 = y0 - (yNMask | 1);
                decimal z6 = z0;
                value += a6 * a6 * a6 * a6 * GradCoord(seed,
                    i + (xNMask & PrimeX), j + (~yNMask & PrimeY), k + (zNMask & PrimeZ), x6, y6, z6);
            }
            else
            {
                decimal a7 = xAFlipMask0 + zAFlipMask0 + a0;
                if (a7 > 0)
                {
                    decimal x7 = x0 - (xNMask | 1);
                    decimal y7 = y0;
                    decimal z7 = z0 - (zNMask | 1);
                    value += a7 * a7 * a7 * a7 * GradCoord(seed,
                        i + (~xNMask & PrimeX), j + (yNMask & PrimeY), k + (~zNMask & PrimeZ), x7, y7, z7);
                }

                decimal a8 = yAFlipMask1 + a1;
                if (a8 > 0)
                {
                    decimal x8 = x1;
                    decimal y8 = (yNMask | 1) + y1;
                    decimal z8 = z1;
                    value += a8 * a8 * a8 * a8 * GradCoord(seed2,
                        i + PrimeX, j + (yNMask & PrimeY << 1), k + PrimeZ, x8, y8, z8);
                    skip9 = true;
                }
            }

            bool skipD = false;
            decimal aA = zAFlipMask0 + a0;
            if (aA > 0)
            {
                decimal xA = x0;
                decimal yA = y0;
                decimal zA = z0 - (zNMask | 1);
                value += aA * aA * aA * aA * GradCoord(seed,
                    i + (xNMask & PrimeX), j + (yNMask & PrimeY), k + (~zNMask & PrimeZ), xA, yA, zA);
            }
            else
            {
                decimal aB = xAFlipMask0 + yAFlipMask0 + a0;
                if (aB > 0)
                {
                    decimal xB = x0 - (xNMask | 1);
                    decimal yB = y0 - (yNMask | 1);
                    decimal zB = z0;
                    value += aB * aB * aB * aB * GradCoord(seed,
                        i + (~xNMask & PrimeX), j + (~yNMask & PrimeY), k + (zNMask & PrimeZ), xB, yB, zB);
                }

                decimal aC = zAFlipMask1 + a1;
                if (aC > 0)
                {
                    decimal xC = x1;
                    decimal yC = y1;
                    decimal zC = (zNMask | 1) + z1;
                    value += aC * aC * aC * aC * GradCoord(seed2,
                        i + PrimeX, j + PrimeY, k + (zNMask & PrimeZ << 1), xC, yC, zC);
                    skipD = true;
                }
            }

            if (!skip5)
            {
                decimal a5 = yAFlipMask1 + zAFlipMask1 + a1;
                if (a5 > 0)
                {
                    decimal x5 = x1;
                    decimal y5 = (yNMask | 1) + y1;
                    decimal z5 = (zNMask | 1) + z1;
                    value += a5 * a5 * a5 * a5 * GradCoord(seed2,
                        i + PrimeX, j + (yNMask & PrimeY << 1), k + (zNMask & PrimeZ << 1), x5, y5, z5);
                }
            }

            if (!skip9)
            {
                decimal a9 = xAFlipMask1 + zAFlipMask1 + a1;
                if (a9 > 0)
                {
                    decimal x9 = (xNMask | 1) + x1;
                    decimal y9 = y1;
                    decimal z9 = (zNMask | 1) + z1;
                    value += a9 * a9 * a9 * a9 * GradCoord(seed2,
                        i + (xNMask & PrimeX * 2), j + PrimeY, k + (zNMask & PrimeZ << 1), x9, y9, z9);
                }
            }

            if (!skipD)
            {
                decimal aD = xAFlipMask1 + yAFlipMask1 + a1;
                if (aD > 0)
                {
                    decimal xD = (xNMask | 1) + x1;
                    decimal yD = (yNMask | 1) + y1;
                    decimal zD = z1;
                    value += aD * aD * aD * aD * GradCoord(seed2,
                        i + (xNMask & PrimeX << 1), j + (yNMask & PrimeY << 1), k + PrimeZ, xD, yD, zD);
                }
            }

            return value * 9.046026385208288m;
        }


        // Cellular Noise

        private decimal SingleCellular(int seed, FNLdecimal x, FNLdecimal y)
        {
            int xr = FastRound(x);
            int yr = FastRound(y);

            decimal distance0 = decimal.MaxValue;
            decimal distance1 = decimal.MaxValue;
            int closestHash = 0;

            decimal cellularJitter = 0.43701595m * mCellularJitterModifier;

            int xPrimed = (xr - 1) * PrimeX;
            int yPrimedBase = (yr - 1) * PrimeY;

            switch (mCellularDistanceFunction)
            {
                default:
                case CellularDistanceFunction.Euclidean:
                case CellularDistanceFunction.EuclideanSq:
                    for (int xi = xr - 1; xi <= xr + 1; xi++)
                    {
                        int yPrimed = yPrimedBase;

                        for (int yi = yr - 1; yi <= yr + 1; yi++)
                        {
                            int hash = Hash(seed, xPrimed, yPrimed);
                            int idx = hash & 255 << 1;

                            decimal vecX = xi - x + RandVecs2D[idx] * cellularJitter;
                            decimal vecY = yi - y + RandVecs2D[idx | 1] * cellularJitter;

                            decimal newDistance = vecX * vecX + vecY * vecY;

                            distance1 = FastMax(FastMin(distance1, newDistance), distance0);
                            if (newDistance < distance0)
                            {
                                distance0 = newDistance;
                                closestHash = hash;
                            }
                            yPrimed += PrimeY;
                        }
                        xPrimed += PrimeX;
                    }
                    break;
                case CellularDistanceFunction.Manhattan:
                    for (int xi = xr - 1; xi <= xr + 1; xi++)
                    {
                        int yPrimed = yPrimedBase;

                        for (int yi = yr - 1; yi <= yr + 1; yi++)
                        {
                            int hash = Hash(seed, xPrimed, yPrimed);
                            int idx = hash & 255 << 1;

                            decimal vecX = xi - x + RandVecs2D[idx] * cellularJitter;
                            decimal vecY = yi - y + RandVecs2D[idx | 1] * cellularJitter;

                            decimal newDistance = FastAbs(vecX) + FastAbs(vecY);

                            distance1 = FastMax(FastMin(distance1, newDistance), distance0);
                            if (newDistance < distance0)
                            {
                                distance0 = newDistance;
                                closestHash = hash;
                            }
                            yPrimed += PrimeY;
                        }
                        xPrimed += PrimeX;
                    }
                    break;
                case CellularDistanceFunction.Hybrid:
                    for (int xi = xr - 1; xi <= xr + 1; xi++)
                    {
                        int yPrimed = yPrimedBase;

                        for (int yi = yr - 1; yi <= yr + 1; yi++)
                        {
                            int hash = Hash(seed, xPrimed, yPrimed);
                            int idx = hash & 255 << 1;

                            decimal vecX = xi - x + RandVecs2D[idx] * cellularJitter;
                            decimal vecY = yi - y + RandVecs2D[idx | 1] * cellularJitter;

                            decimal newDistance = FastAbs(vecX) + FastAbs(vecY) + vecX * vecX + vecY * vecY;

                            distance1 = FastMax(FastMin(distance1, newDistance), distance0);
                            if (newDistance < distance0)
                            {
                                distance0 = newDistance;
                                closestHash = hash;
                            }
                            yPrimed += PrimeY;
                        }
                        xPrimed += PrimeX;
                    }
                    break;
            }

            if (mCellularDistanceFunction == CellularDistanceFunction.Euclidean && mCellularReturnType >= CellularReturnType.Distance)
            {
                distance0 = FastSqrt(distance0);

                if (mCellularReturnType >= CellularReturnType.Distance2)
                {
                    distance1 = FastSqrt(distance1);
                }
            }

            return mCellularReturnType switch
            {
                CellularReturnType.CellValue => closestHash * (1 / 2147483648.0m),
                CellularReturnType.Distance => distance0 - 1,
                CellularReturnType.Distance2 => distance1 - 1,
                CellularReturnType.Distance2Add => (distance1 + distance0) * 0.5m - 1,
                CellularReturnType.Distance2Sub => distance1 - distance0 - 1,
                CellularReturnType.Distance2Mul => distance1 * distance0 * 0.5m - 1,
                CellularReturnType.Distance2Div => distance0 / distance1 - 1,
                _ => 0,
            };
        }

        private decimal SingleCellular(int seed, FNLdecimal x, FNLdecimal y, FNLdecimal z)
        {
            int xr = FastRound(x);
            int yr = FastRound(y);
            int zr = FastRound(z);

            decimal distance0 = decimal.MaxValue;
            decimal distance1 = decimal.MaxValue;
            int closestHash = 0;

            decimal cellularJitter = 0.39614353m * mCellularJitterModifier;

            int xPrimed = (xr - 1) * PrimeX;
            int yPrimedBase = (yr - 1) * PrimeY;
            int zPrimedBase = (zr - 1) * PrimeZ;

            switch (mCellularDistanceFunction)
            {
                case CellularDistanceFunction.Euclidean:
                case CellularDistanceFunction.EuclideanSq:
                    for (int xi = xr - 1; xi <= xr + 1; xi++)
                    {
                        int yPrimed = yPrimedBase;

                        for (int yi = yr - 1; yi <= yr + 1; yi++)
                        {
                            int zPrimed = zPrimedBase;

                            for (int zi = zr - 1; zi <= zr + 1; zi++)
                            {
                                int hash = Hash(seed, xPrimed, yPrimed, zPrimed);
                                int idx = hash & 255 << 2;

                                decimal vecX = xi - x + RandVecs3D[idx] * cellularJitter;
                                decimal vecY = yi - y + RandVecs3D[idx | 1] * cellularJitter;
                                decimal vecZ = zi - z + RandVecs3D[idx | 2] * cellularJitter;

                                decimal newDistance = vecX * vecX + vecY * vecY + vecZ * vecZ;

                                distance1 = FastMax(FastMin(distance1, newDistance), distance0);
                                if (newDistance < distance0)
                                {
                                    distance0 = newDistance;
                                    closestHash = hash;
                                }
                                zPrimed += PrimeZ;
                            }
                            yPrimed += PrimeY;
                        }
                        xPrimed += PrimeX;
                    }
                    break;
                case CellularDistanceFunction.Manhattan:
                    for (int xi = xr - 1; xi <= xr + 1; xi++)
                    {
                        int yPrimed = yPrimedBase;

                        for (int yi = yr - 1; yi <= yr + 1; yi++)
                        {
                            int zPrimed = zPrimedBase;

                            for (int zi = zr - 1; zi <= zr + 1; zi++)
                            {
                                int hash = Hash(seed, xPrimed, yPrimed, zPrimed);
                                int idx = hash & 255 << 2;

                                decimal vecX = xi - x + RandVecs3D[idx] * cellularJitter;
                                decimal vecY = yi - y + RandVecs3D[idx | 1] * cellularJitter;
                                decimal vecZ = zi - z + RandVecs3D[idx | 2] * cellularJitter;

                                decimal newDistance = FastAbs(vecX) + FastAbs(vecY) + FastAbs(vecZ);

                                distance1 = FastMax(FastMin(distance1, newDistance), distance0);
                                if (newDistance < distance0)
                                {
                                    distance0 = newDistance;
                                    closestHash = hash;
                                }
                                zPrimed += PrimeZ;
                            }
                            yPrimed += PrimeY;
                        }
                        xPrimed += PrimeX;
                    }
                    break;
                case CellularDistanceFunction.Hybrid:
                    for (int xi = xr - 1; xi <= xr + 1; xi++)
                    {
                        int yPrimed = yPrimedBase;

                        for (int yi = yr - 1; yi <= yr + 1; yi++)
                        {
                            int zPrimed = zPrimedBase;

                            for (int zi = zr - 1; zi <= zr + 1; zi++)
                            {
                                int hash = Hash(seed, xPrimed, yPrimed, zPrimed);
                                int idx = hash & 255 << 2;

                                decimal vecX = xi - x + RandVecs3D[idx] * cellularJitter;
                                decimal vecY = yi - y + RandVecs3D[idx | 1] * cellularJitter;
                                decimal vecZ = zi - z + RandVecs3D[idx | 2] * cellularJitter;

                                decimal newDistance = FastAbs(vecX) + FastAbs(vecY) + FastAbs(vecZ) + vecX * vecX + vecY * vecY + vecZ * vecZ;

                                distance1 = FastMax(FastMin(distance1, newDistance), distance0);
                                if (newDistance < distance0)
                                {
                                    distance0 = newDistance;
                                    closestHash = hash;
                                }
                                zPrimed += PrimeZ;
                            }
                            yPrimed += PrimeY;
                        }
                        xPrimed += PrimeX;
                    }
                    break;
                default:
                    break;
            }

            if (mCellularDistanceFunction == CellularDistanceFunction.Euclidean && mCellularReturnType >= CellularReturnType.Distance)
            {
                distance0 = FastSqrt(distance0);

                if (mCellularReturnType >= CellularReturnType.Distance2)
                {
                    distance1 = FastSqrt(distance1);
                }
            }

            return mCellularReturnType switch
            {
                CellularReturnType.CellValue => closestHash * (1 / 2147483648.0m),
                CellularReturnType.Distance => distance0 - 1,
                CellularReturnType.Distance2 => distance1 - 1,
                CellularReturnType.Distance2Add => (distance1 + distance0) * 0.5m - 1,
                CellularReturnType.Distance2Sub => distance1 - distance0 - 1,
                CellularReturnType.Distance2Mul => distance1 * distance0 * 0.5m - 1,
                CellularReturnType.Distance2Div => distance0 / distance1 - 1,
                _ => 0,
            };
        }


        // Perlin Noise

        private static decimal SinglePerlin(int seed, FNLdecimal x, FNLdecimal y)
        {
            int x0 = FastFloor(x);
            int y0 = FastFloor(y);

            decimal xd0 = x - x0;
            decimal yd0 = y - y0;
            decimal xd1 = xd0 - 1;
            decimal yd1 = yd0 - 1;

            decimal xs = InterpQuintic(xd0);
            decimal ys = InterpQuintic(yd0);

            x0 *= PrimeX;
            y0 *= PrimeY;
            int x1 = x0 + PrimeX;
            int y1 = y0 + PrimeY;

            decimal xf0 = Lerp(GradCoord(seed, x0, y0, xd0, yd0), GradCoord(seed, x1, y0, xd1, yd0), xs);
            decimal xf1 = Lerp(GradCoord(seed, x0, y1, xd0, yd1), GradCoord(seed, x1, y1, xd1, yd1), xs);

            return Lerp(xf0, xf1, ys) * 1.4247691104677813m;
        }

        private static decimal SinglePerlin(int seed, FNLdecimal x, FNLdecimal y, FNLdecimal z)
        {
            int x0 = FastFloor(x);
            int y0 = FastFloor(y);
            int z0 = FastFloor(z);

            decimal xd0 = x - x0;
            decimal yd0 = y - y0;
            decimal zd0 = z - z0;
            decimal xd1 = xd0 - 1;
            decimal yd1 = yd0 - 1;
            decimal zd1 = zd0 - 1;

            decimal xs = InterpQuintic(xd0);
            decimal ys = InterpQuintic(yd0);
            decimal zs = InterpQuintic(zd0);

            x0 *= PrimeX;
            y0 *= PrimeY;
            z0 *= PrimeZ;
            int x1 = x0 + PrimeX;
            int y1 = y0 + PrimeY;
            int z1 = z0 + PrimeZ;

            decimal xf00 = Lerp(GradCoord(seed, x0, y0, z0, xd0, yd0, zd0), GradCoord(seed, x1, y0, z0, xd1, yd0, zd0), xs);
            decimal xf10 = Lerp(GradCoord(seed, x0, y1, z0, xd0, yd1, zd0), GradCoord(seed, x1, y1, z0, xd1, yd1, zd0), xs);
            decimal xf01 = Lerp(GradCoord(seed, x0, y0, z1, xd0, yd0, zd1), GradCoord(seed, x1, y0, z1, xd1, yd0, zd1), xs);
            decimal xf11 = Lerp(GradCoord(seed, x0, y1, z1, xd0, yd1, zd1), GradCoord(seed, x1, y1, z1, xd1, yd1, zd1), xs);

            decimal yf0 = Lerp(xf00, xf10, ys);
            decimal yf1 = Lerp(xf01, xf11, ys);

            return Lerp(yf0, yf1, zs) * 0.964921414852142333984375m;
        }


        // Value Cubic Noise

        private static decimal SingleValueCubic(int seed, FNLdecimal x, FNLdecimal y)
        {
            int x1 = FastFloor(x);
            int y1 = FastFloor(y);

            decimal xs = x - x1;
            decimal ys = y - y1;

            x1 *= PrimeX;
            y1 *= PrimeY;
            int x0 = x1 - PrimeX;
            int y0 = y1 - PrimeY;
            int x2 = x1 + PrimeX;
            int y2 = y1 + PrimeY;
            int x3 = x1 + unchecked(PrimeX * 2);
            int y3 = y1 + unchecked(PrimeY * 2);

            return CubicLerp(
                CubicLerp(ValCoord(seed, x0, y0), ValCoord(seed, x1, y0), ValCoord(seed, x2, y0), ValCoord(seed, x3, y0),
                xs),
                CubicLerp(ValCoord(seed, x0, y1), ValCoord(seed, x1, y1), ValCoord(seed, x2, y1), ValCoord(seed, x3, y1),
                xs),
                CubicLerp(ValCoord(seed, x0, y2), ValCoord(seed, x1, y2), ValCoord(seed, x2, y2), ValCoord(seed, x3, y2),
                xs),
                CubicLerp(ValCoord(seed, x0, y3), ValCoord(seed, x1, y3), ValCoord(seed, x2, y3), ValCoord(seed, x3, y3),
                xs),
                ys) * (1 / (1.5m * 1.5m));
        }

        private static decimal SingleValueCubic(int seed, FNLdecimal x, FNLdecimal y, FNLdecimal z)
        {
            int x1 = FastFloor(x);
            int y1 = FastFloor(y);
            int z1 = FastFloor(z);

            decimal xs = x - x1;
            decimal ys = y - y1;
            decimal zs = z - z1;

            x1 *= PrimeX;
            y1 *= PrimeY;
            z1 *= PrimeZ;

            int x0 = x1 - PrimeX;
            int y0 = y1 - PrimeY;
            int z0 = z1 - PrimeZ;
            int x2 = x1 + PrimeX;
            int y2 = y1 + PrimeY;
            int z2 = z1 + PrimeZ;
            int x3 = x1 + unchecked(PrimeX * 2);
            int y3 = y1 + unchecked(PrimeY * 2);
            int z3 = z1 + unchecked(PrimeZ * 2);


            return CubicLerp(
                CubicLerp(
                CubicLerp(ValCoord(seed, x0, y0, z0), ValCoord(seed, x1, y0, z0), ValCoord(seed, x2, y0, z0), ValCoord(seed, x3, y0, z0), xs),
                CubicLerp(ValCoord(seed, x0, y1, z0), ValCoord(seed, x1, y1, z0), ValCoord(seed, x2, y1, z0), ValCoord(seed, x3, y1, z0), xs),
                CubicLerp(ValCoord(seed, x0, y2, z0), ValCoord(seed, x1, y2, z0), ValCoord(seed, x2, y2, z0), ValCoord(seed, x3, y2, z0), xs),
                CubicLerp(ValCoord(seed, x0, y3, z0), ValCoord(seed, x1, y3, z0), ValCoord(seed, x2, y3, z0), ValCoord(seed, x3, y3, z0), xs),
                ys),
                CubicLerp(
                CubicLerp(ValCoord(seed, x0, y0, z1), ValCoord(seed, x1, y0, z1), ValCoord(seed, x2, y0, z1), ValCoord(seed, x3, y0, z1), xs),
                CubicLerp(ValCoord(seed, x0, y1, z1), ValCoord(seed, x1, y1, z1), ValCoord(seed, x2, y1, z1), ValCoord(seed, x3, y1, z1), xs),
                CubicLerp(ValCoord(seed, x0, y2, z1), ValCoord(seed, x1, y2, z1), ValCoord(seed, x2, y2, z1), ValCoord(seed, x3, y2, z1), xs),
                CubicLerp(ValCoord(seed, x0, y3, z1), ValCoord(seed, x1, y3, z1), ValCoord(seed, x2, y3, z1), ValCoord(seed, x3, y3, z1), xs),
                ys),
                CubicLerp(
                CubicLerp(ValCoord(seed, x0, y0, z2), ValCoord(seed, x1, y0, z2), ValCoord(seed, x2, y0, z2), ValCoord(seed, x3, y0, z2), xs),
                CubicLerp(ValCoord(seed, x0, y1, z2), ValCoord(seed, x1, y1, z2), ValCoord(seed, x2, y1, z2), ValCoord(seed, x3, y1, z2), xs),
                CubicLerp(ValCoord(seed, x0, y2, z2), ValCoord(seed, x1, y2, z2), ValCoord(seed, x2, y2, z2), ValCoord(seed, x3, y2, z2), xs),
                CubicLerp(ValCoord(seed, x0, y3, z2), ValCoord(seed, x1, y3, z2), ValCoord(seed, x2, y3, z2), ValCoord(seed, x3, y3, z2), xs),
                ys),
                CubicLerp(
                CubicLerp(ValCoord(seed, x0, y0, z3), ValCoord(seed, x1, y0, z3), ValCoord(seed, x2, y0, z3), ValCoord(seed, x3, y0, z3), xs),
                CubicLerp(ValCoord(seed, x0, y1, z3), ValCoord(seed, x1, y1, z3), ValCoord(seed, x2, y1, z3), ValCoord(seed, x3, y1, z3), xs),
                CubicLerp(ValCoord(seed, x0, y2, z3), ValCoord(seed, x1, y2, z3), ValCoord(seed, x2, y2, z3), ValCoord(seed, x3, y2, z3), xs),
                CubicLerp(ValCoord(seed, x0, y3, z3), ValCoord(seed, x1, y3, z3), ValCoord(seed, x2, y3, z3), ValCoord(seed, x3, y3, z3), xs),
                ys),
                zs) * (1 / (1.5m * 1.5m * 1.5m));
        }


        // Value Noise

        private static decimal SingleValue(int seed, FNLdecimal x, FNLdecimal y)
        {
            int x0 = FastFloor(x);
            int y0 = FastFloor(y);

            decimal xs = InterpHermite(x - x0);
            decimal ys = InterpHermite(y - y0);

            x0 *= PrimeX;
            y0 *= PrimeY;
            int x1 = x0 + PrimeX;
            int y1 = y0 + PrimeY;

            decimal xf0 = Lerp(ValCoord(seed, x0, y0), ValCoord(seed, x1, y0), xs);
            decimal xf1 = Lerp(ValCoord(seed, x0, y1), ValCoord(seed, x1, y1), xs);

            return Lerp(xf0, xf1, ys);
        }

        private static decimal SingleValue(int seed, FNLdecimal x, FNLdecimal y, FNLdecimal z)
        {
            int x0 = FastFloor(x);
            int y0 = FastFloor(y);
            int z0 = FastFloor(z);

            decimal xs = InterpHermite(x - x0);
            decimal ys = InterpHermite(y - y0);
            decimal zs = InterpHermite(z - z0);

            x0 *= PrimeX;
            y0 *= PrimeY;
            z0 *= PrimeZ;
            int x1 = x0 + PrimeX;
            int y1 = y0 + PrimeY;
            int z1 = z0 + PrimeZ;

            decimal xf00 = Lerp(ValCoord(seed, x0, y0, z0), ValCoord(seed, x1, y0, z0), xs);
            decimal xf10 = Lerp(ValCoord(seed, x0, y1, z0), ValCoord(seed, x1, y1, z0), xs);
            decimal xf01 = Lerp(ValCoord(seed, x0, y0, z1), ValCoord(seed, x1, y0, z1), xs);
            decimal xf11 = Lerp(ValCoord(seed, x0, y1, z1), ValCoord(seed, x1, y1, z1), xs);

            decimal yf0 = Lerp(xf00, xf10, ys);
            decimal yf1 = Lerp(xf01, xf11, ys);

            return Lerp(yf0, yf1, zs);
        }


        // Domain Warp

        private void DoSingleDomainWarp(int seed, decimal amp, decimal freq, FNLdecimal x, FNLdecimal y, ref FNLdecimal xr, ref FNLdecimal yr)
        {
            switch (mDomainWarpType)
            {
                case DomainWarpType.OpenSimplex2:
                    SingleDomainWarpSimplexGradient(seed, amp * 38.283687591552734375m, freq, x, y, ref xr, ref yr, false);
                    break;
                case DomainWarpType.OpenSimplex2Reduced:
                    SingleDomainWarpSimplexGradient(seed, amp * 16.0m, freq, x, y, ref xr, ref yr, true);
                    break;
                case DomainWarpType.BasicGrid:
                    SingleDomainWarpBasicGrid(seed, amp, freq, x, y, ref xr, ref yr);
                    break;
            }
        }

        private void DoSingleDomainWarp(int seed, decimal amp, decimal freq, FNLdecimal x, FNLdecimal y, FNLdecimal z, ref FNLdecimal xr, ref FNLdecimal yr, ref FNLdecimal zr)
        {
            switch (mDomainWarpType)
            {
                case DomainWarpType.OpenSimplex2:
                    SingleDomainWarpOpenSimplex2Gradient(seed, amp * 32.69428253173828125m, freq, x, y, z, ref xr, ref yr, ref zr, false);
                    break;
                case DomainWarpType.OpenSimplex2Reduced:
                    SingleDomainWarpOpenSimplex2Gradient(seed, amp * 7.71604938271605m, freq, x, y, z, ref xr, ref yr, ref zr, true);
                    break;
                case DomainWarpType.BasicGrid:
                    SingleDomainWarpBasicGrid(seed, amp, freq, x, y, z, ref xr, ref yr, ref zr);
                    break;
            }
        }


        // Domain Warp Single Wrapper

        private void DomainWarpSingle(ref FNLdecimal x, ref FNLdecimal y)
        {
            int seed = mSeed;
            decimal amp = mDomainWarpAmp * mFractalBounding;
            decimal freq = mFrequency;

            FNLdecimal xs = x;
            FNLdecimal ys = y;
            TransformDomainWarpCoordinate(ref xs, ref ys);

            DoSingleDomainWarp(seed, amp, freq, xs, ys, ref x, ref y);
        }

        private void DomainWarpSingle(ref FNLdecimal x, ref FNLdecimal y, ref FNLdecimal z)
        {
            int seed = mSeed;
            decimal amp = mDomainWarpAmp * mFractalBounding;
            decimal freq = mFrequency;

            FNLdecimal xs = x;
            FNLdecimal ys = y;
            FNLdecimal zs = z;
            TransformDomainWarpCoordinate(ref xs, ref ys, ref zs);

            DoSingleDomainWarp(seed, amp, freq, xs, ys, zs, ref x, ref y, ref z);
        }


        // Domain Warp Fractal Progressive

        private void DomainWarpFractalProgressive(ref FNLdecimal x, ref FNLdecimal y)
        {
            int seed = mSeed;
            decimal amp = mDomainWarpAmp * mFractalBounding;
            decimal freq = mFrequency;

            for (int i = 0; i < mOctaves; i++)
            {
                FNLdecimal xs = x;
                FNLdecimal ys = y;
                TransformDomainWarpCoordinate(ref xs, ref ys);

                DoSingleDomainWarp(seed, amp, freq, xs, ys, ref x, ref y);

                seed++;
                amp *= mGain;
                freq *= mLacunarity;
            }
        }

        private void DomainWarpFractalProgressive(ref FNLdecimal x, ref FNLdecimal y, ref FNLdecimal z)
        {
            int seed = mSeed;
            decimal amp = mDomainWarpAmp * mFractalBounding;
            decimal freq = mFrequency;

            for (int i = 0; i < mOctaves; i++)
            {
                FNLdecimal xs = x;
                FNLdecimal ys = y;
                FNLdecimal zs = z;
                TransformDomainWarpCoordinate(ref xs, ref ys, ref zs);

                DoSingleDomainWarp(seed, amp, freq, xs, ys, zs, ref x, ref y, ref z);

                seed++;
                amp *= mGain;
                freq *= mLacunarity;
            }
        }


        // Domain Warp Fractal Independant
        private void DomainWarpFractalIndependent(ref FNLdecimal x, ref FNLdecimal y)
        {
            FNLdecimal xs = x;
            FNLdecimal ys = y;
            TransformDomainWarpCoordinate(ref xs, ref ys);

            int seed = mSeed;
            decimal amp = mDomainWarpAmp * mFractalBounding;
            decimal freq = mFrequency;

            for (int i = 0; i < mOctaves; i++)
            {
                DoSingleDomainWarp(seed, amp, freq, xs, ys, ref x, ref y);

                seed++;
                amp *= mGain;
                freq *= mLacunarity;
            }
        }

        private void DomainWarpFractalIndependent(ref FNLdecimal x, ref FNLdecimal y, ref FNLdecimal z)
        {
            FNLdecimal xs = x;
            FNLdecimal ys = y;
            FNLdecimal zs = z;
            TransformDomainWarpCoordinate(ref xs, ref ys, ref zs);

            int seed = mSeed;
            decimal amp = mDomainWarpAmp * mFractalBounding;
            decimal freq = mFrequency;

            for (int i = 0; i < mOctaves; i++)
            {
                DoSingleDomainWarp(seed, amp, freq, xs, ys, zs, ref x, ref y, ref z);

                seed++;
                amp *= mGain;
                freq *= mLacunarity;
            }
        }


        // Domain Warp Basic Grid

        private static void SingleDomainWarpBasicGrid(int seed, decimal warpAmp, decimal frequency, FNLdecimal x, FNLdecimal y, ref FNLdecimal xr, ref FNLdecimal yr)
        {
            FNLdecimal xf = x * frequency;
            FNLdecimal yf = y * frequency;

            int x0 = FastFloor(xf);
            int y0 = FastFloor(yf);

            decimal xs = InterpHermite(xf - x0);
            decimal ys = InterpHermite(yf - y0);

            x0 *= PrimeX;
            y0 *= PrimeY;
            int x1 = x0 + PrimeX;
            int y1 = y0 + PrimeY;

            int hash0 = Hash(seed, x0, y0) & 255 << 1;
            int hash1 = Hash(seed, x1, y0) & 255 << 1;

            decimal lx0x = Lerp(RandVecs2D[hash0], RandVecs2D[hash1], xs);
            decimal ly0x = Lerp(RandVecs2D[hash0 | 1], RandVecs2D[hash1 | 1], xs);

            hash0 = Hash(seed, x0, y1) & 255 << 1;
            hash1 = Hash(seed, x1, y1) & 255 << 1;

            decimal lx1x = Lerp(RandVecs2D[hash0], RandVecs2D[hash1], xs);
            decimal ly1x = Lerp(RandVecs2D[hash0 | 1], RandVecs2D[hash1 | 1], xs);

            xr += Lerp(lx0x, lx1x, ys) * warpAmp;
            yr += Lerp(ly0x, ly1x, ys) * warpAmp;
        }

        private static void SingleDomainWarpBasicGrid(int seed, decimal warpAmp, decimal frequency, FNLdecimal x, FNLdecimal y, FNLdecimal z, ref FNLdecimal xr, ref FNLdecimal yr, ref FNLdecimal zr)
        {
            FNLdecimal xf = x * frequency;
            FNLdecimal yf = y * frequency;
            FNLdecimal zf = z * frequency;

            int x0 = FastFloor(xf);
            int y0 = FastFloor(yf);
            int z0 = FastFloor(zf);

            decimal xs = InterpHermite(xf - x0);
            decimal ys = InterpHermite(yf - y0);
            decimal zs = InterpHermite(zf - z0);

            x0 *= PrimeX;
            y0 *= PrimeY;
            z0 *= PrimeZ;
            int x1 = x0 + PrimeX;
            int y1 = y0 + PrimeY;
            int z1 = z0 + PrimeZ;

            int hash0 = Hash(seed, x0, y0, z0) & 255 << 2;
            int hash1 = Hash(seed, x1, y0, z0) & 255 << 2;

            decimal lx0x = Lerp(RandVecs3D[hash0], RandVecs3D[hash1], xs);
            decimal ly0x = Lerp(RandVecs3D[hash0 | 1], RandVecs3D[hash1 | 1], xs);
            decimal lz0x = Lerp(RandVecs3D[hash0 | 2], RandVecs3D[hash1 | 2], xs);

            hash0 = Hash(seed, x0, y1, z0) & 255 << 2;
            hash1 = Hash(seed, x1, y1, z0) & 255 << 2;

            decimal lx1x = Lerp(RandVecs3D[hash0], RandVecs3D[hash1], xs);
            decimal ly1x = Lerp(RandVecs3D[hash0 | 1], RandVecs3D[hash1 | 1], xs);
            decimal lz1x = Lerp(RandVecs3D[hash0 | 2], RandVecs3D[hash1 | 2], xs);

            decimal lx0y = Lerp(lx0x, lx1x, ys);
            decimal ly0y = Lerp(ly0x, ly1x, ys);
            decimal lz0y = Lerp(lz0x, lz1x, ys);

            hash0 = Hash(seed, x0, y0, z1) & 255 << 2;
            hash1 = Hash(seed, x1, y0, z1) & 255 << 2;

            lx0x = Lerp(RandVecs3D[hash0], RandVecs3D[hash1], xs);
            ly0x = Lerp(RandVecs3D[hash0 | 1], RandVecs3D[hash1 | 1], xs);
            lz0x = Lerp(RandVecs3D[hash0 | 2], RandVecs3D[hash1 | 2], xs);

            hash0 = Hash(seed, x0, y1, z1) & 255 << 2;
            hash1 = Hash(seed, x1, y1, z1) & 255 << 2;

            lx1x = Lerp(RandVecs3D[hash0], RandVecs3D[hash1], xs);
            ly1x = Lerp(RandVecs3D[hash0 | 1], RandVecs3D[hash1 | 1], xs);
            lz1x = Lerp(RandVecs3D[hash0 | 2], RandVecs3D[hash1 | 2], xs);

            xr += Lerp(lx0y, Lerp(lx0x, lx1x, ys), zs) * warpAmp;
            yr += Lerp(ly0y, Lerp(ly0x, ly1x, ys), zs) * warpAmp;
            zr += Lerp(lz0y, Lerp(lz0x, lz1x, ys), zs) * warpAmp;
        }


        // Domain Warp Simplex/OpenSimplex2
        private static void SingleDomainWarpSimplexGradient(int seed, decimal warpAmp, decimal frequency, FNLdecimal x, FNLdecimal y, ref FNLdecimal xr, ref FNLdecimal yr, bool outGradOnly)
        {
            const decimal SQRT3 = 1.7320508075688772935274463415059m;
            const decimal G2 = (3 - SQRT3) / 6;

            x *= frequency;
            y *= frequency;

            /*
             * --- Skew moved to TransformNoiseCoordinate method ---
             * const FNdecimal F2 = 0.5m * (SQRT3 - 1);
             * FNdecimal s = (x + y) * F2;
             * x += s; y += s;
            */

            int i = FastFloor(x);
            int j = FastFloor(y);
            decimal xi = x - i;
            decimal yi = y - j;

            decimal t = (xi + yi) * G2;
            decimal x0 = xi - t;
            decimal y0 = yi - t;

            i *= PrimeX;
            j *= PrimeY;

            decimal vx, vy;
            vx = vy = 0;

            decimal a = 0.5m - x0 * x0 - y0 * y0;
            if (a > 0)
            {
                decimal aaaa = a * a * a * a;
                decimal xo, yo;
                if (outGradOnly)
                    GradCoordOut(seed, i, j, out xo, out yo);
                else
                    GradCoordDual(seed, i, j, x0, y0, out xo, out yo);
                vx += aaaa * xo;
                vy += aaaa * yo;
            }

            decimal c = 2 * (1 - 2 * G2) * (1 / G2 - 2) * t + -2 * (1 - 2 * G2) * (1 - 2 * G2) + a;
            if (c > 0)
            {
                decimal x2 = x0 + (2 * G2 - 1);
                decimal y2 = y0 + (2 * G2 - 1);
                decimal cccc = c * c * c * c;
                decimal xo, yo;
                if (outGradOnly)
                    GradCoordOut(seed, i + PrimeX, j + PrimeY, out xo, out yo);
                else
                    GradCoordDual(seed, i + PrimeX, j + PrimeY, x2, y2, out xo, out yo);
                vx += cccc * xo;
                vy += cccc * yo;
            }

            if (y0 > x0)
            {
                decimal x1 = x0 + G2;
                decimal y1 = y0 + (G2 - 1);
                decimal b = 0.5m - x1 * x1 - y1 * y1;
                if (b > 0)
                {
                    decimal bbbb = b * b * b * b;
                    decimal xo, yo;
                    if (outGradOnly)
                        GradCoordOut(seed, i, j + PrimeY, out xo, out yo);
                    else
                        GradCoordDual(seed, i, j + PrimeY, x1, y1, out xo, out yo);
                    vx += bbbb * xo;
                    vy += bbbb * yo;
                }
            }
            else
            {
                decimal x1 = x0 + (G2 - 1);
                decimal y1 = y0 + G2;
                decimal b = 0.5m - x1 * x1 - y1 * y1;
                if (b > 0)
                {
                    decimal bbbb = b * b * b * b;
                    decimal xo, yo;
                    if (outGradOnly)
                        GradCoordOut(seed, i + PrimeX, j, out xo, out yo);
                    else
                        GradCoordDual(seed, i + PrimeX, j, x1, y1, out xo, out yo);
                    vx += bbbb * xo;
                    vy += bbbb * yo;
                }
            }

            xr += vx * warpAmp;
            yr += vy * warpAmp;
        }

        private static void SingleDomainWarpOpenSimplex2Gradient(int seed, decimal warpAmp, decimal frequency, FNLdecimal x, FNLdecimal y, FNLdecimal z, ref FNLdecimal xr, ref FNLdecimal yr, ref FNLdecimal zr, bool outGradOnly)
        {
            x *= frequency;
            y *= frequency;
            z *= frequency;

            /*
             * --- Rotation moved to TransformDomainWarpCoordinate method ---
             * const FNdecimal R3 = (FNdecimal)(2.0 / 3.0);
             * FNdecimal r = (x + y + z) * R3; // Rotation, not skew
             * x = r - x; y = r - y; z = r - z;
            */

            int i = FastRound(x);
            int j = FastRound(y);
            int k = FastRound(z);
            decimal x0 = x - i;
            decimal y0 = y - j;
            decimal z0 = z - k;

            int xNSign = (int)(-x0 - 1.0m) | 1;
            int yNSign = (int)(-y0 - 1.0m) | 1;
            int zNSign = (int)(-z0 - 1.0m) | 1;

            decimal ax0 = xNSign * -x0;
            decimal ay0 = yNSign * -y0;
            decimal az0 = zNSign * -z0;

            i *= PrimeX;
            j *= PrimeY;
            k *= PrimeZ;

            decimal vx, vy, vz;
            vx = vy = vz = 0;

            decimal a = 0.6m - x0 * x0 - (y0 * y0 + z0 * z0);
            for (int l = 0; ; l++)
            {
                if (a > 0)
                {
                    decimal aaaa = a * a * a * a;
                    decimal xo, yo, zo;
                    if (outGradOnly)
                        GradCoordOut(seed, i, j, k, out xo, out yo, out zo);
                    else
                        GradCoordDual(seed, i, j, k, x0, y0, z0, out xo, out yo, out zo);
                    vx += aaaa * xo;
                    vy += aaaa * yo;
                    vz += aaaa * zo;
                }

                decimal b = a;
                int i1 = i;
                int j1 = j;
                int k1 = k;
                decimal x1 = x0;
                decimal y1 = y0;
                decimal z1 = z0;

                if (ax0 >= ay0 && ax0 >= az0)
                {
                    x1 += xNSign;
                    b = b + ax0 + ax0;
                    i1 -= xNSign * PrimeX;
                }
                else if (ay0 > ax0 && ay0 >= az0)
                {
                    y1 += yNSign;
                    b = b + ay0 + ay0;
                    j1 -= yNSign * PrimeY;
                }
                else
                {
                    z1 += zNSign;
                    b = b + az0 + az0;
                    k1 -= zNSign * PrimeZ;
                }

                if (b > 1)
                {
                    b -= 1;
                    decimal bbbb = b * b * b * b;
                    decimal xo, yo, zo;
                    if (outGradOnly)
                        GradCoordOut(seed, i1, j1, k1, out xo, out yo, out zo);
                    else
                        GradCoordDual(seed, i1, j1, k1, x1, y1, z1, out xo, out yo, out zo);
                    vx += bbbb * xo;
                    vy += bbbb * yo;
                    vz += bbbb * zo;
                }

                if (l == 1) break;

                ax0 = 0.5m - ax0;
                ay0 = 0.5m - ay0;
                az0 = 0.5m - az0;

                x0 = xNSign * ax0;
                y0 = yNSign * ay0;
                z0 = zNSign * az0;

                a += 0.75m - ax0 - (ay0 + az0);

                i += xNSign >> 1 & PrimeX;
                j += yNSign >> 1 & PrimeY;
                k += zNSign >> 1 & PrimeZ;

                xNSign = -xNSign;
                yNSign = -yNSign;
                zNSign = -zNSign;

                seed += 1293373;
            }

            xr += vx * warpAmp;
            yr += vy * warpAmp;
            zr += vz * warpAmp;
        }
    }
}